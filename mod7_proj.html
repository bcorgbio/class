<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Module 7 Project</title>

<script src="site_libs/header-attrs-2.29/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">BIOL 3140</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="schedule.html">Schedule</a>
</li>
<li>
  <a href="at_a_glance.html">Calendar</a>
</li>
<li>
  <a href="WCRs.html">WCRs</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Projects
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Phase I</li>
    <li>
      <a href="phaseI_rubric.html">Phase I report guidlines</a>
    </li>
    <li>
      <a href="mod1_proj.html">Module 1 Project</a>
    </li>
    <li>
      <a href="mod2_proj.html">Module 2 Project</a>
    </li>
    <li>
      <a href="mod3_proj.html">Module 3 Project</a>
    </li>
    <li>
      <a href="mod4_proj.html">Module 4 Project</a>
    </li>
    <li class="dropdown-header">Phase II</li>
    <li>
      <a href="phaseII_rubric.html">Phase II report guidlines</a>
    </li>
    <li>
      <a href="mod5_proj.html">Module 5 Project</a>
    </li>
    <li>
      <a href="mod6_proj.html">Module 6 Project</a>
    </li>
    <li>
      <a href="mod7_proj.html">Module 7 Project</a>
    </li>
    <li class="dropdown-header">Phase III</li>
    <li>
      <a href="phaseIII_rubric.html">Phase III report guidlines</a>
    </li>
    <li>
      <a href="final_proj.html">Final Project</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://github.com/orgs/bcorgbio/discussions">BIOL 3140 Discussion</a>
</li>
<li>
  <a href="https://bostoncollege.instructure.com/courses/1672404/gradebook">Grades on Canvas</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Peer Contribution Evaluations
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="peer_contributions.html">Peer Contribution Evaluation Guidelines</a>
    </li>
    <li>
      <a href="https://forms.gle/FirWiqsQGvANSWsG6">Author Contribution Evaluation Form</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Module 7 Project</h1>

</div>


<style>
div.green { background-color:#c7d1c0; border-radius: 5px; padding: 20px;}
</style>
<!-- Add icon library -->
<p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"></p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Each spring in the northern hemisphere (the Neartic), many
neotropical passerines undertake long-distance migrations from Central
and South America to temperate latitudes to forage and breed. Many of
these species fly non-stop over the Gulf of Mexico and arrive on land
between Texas and Florida. These species are therefore described as
trans-Gulf migrants (TGMs). The date when any individual migrant arrives
on its breeding grounds has important fitness consequences and the
evolution of this phenological event is likely the result of balancing
important tradeoffs. For instance, arriving early increases the chances
of finding a mate and breeding multiple times, however later arrival
ensures higher food availability in these temperate and seasonal
ecosystems <span class="citation">(Smith and Moore 2005; Newton
2008)</span>.</p>
<p>In the context of a changing climate, failure of TGMs to shift
arrival date at breeding areas in response to warmer spring temperatures
may result in population declines <span class="citation">(Both et al.
2006)</span>. If and how TGMs and other long-distance migrants shift
their spring arrival in temperate North America in response to local
temperature changes remains hotly debated <span class="citation">(Smith
and Moore 2005; Knudsen et al. 2011)</span>. In studying the effects of
changes in local environmental parameters linked to climate change on
migration phenology, scientists have traditionally relied on field, <a
href="https://www.fws.gov/faq/bandingfaq.html">banding</a>, or tracking
studies <span class="citation">(e.g., Smith and Moore 2005; Askeyev,
Sparks, and Askeyev 2009)</span>. These studies are often limited in
temporal scope and in scale due to the few experts who are trained in
this work</p>
<p>In recent decades, there has been a marked increase in public
interest in species conservation. Coupled with this is the development
of several online programs in which amateur birders can submit bird
observations. The Cornell Laboratory of Ornithology and the National
Audubon Society have established the most popular and far-reaching of
these programs: <a href="http://www.ebird.org">eBird</a>. Since its
launch in 2002, eBird has collected and compiled well over 100 million
bird observations from many thousand contributors. In addition to new
checklists, users have also entered historical observations, so that
eBird includes data prior to 2002 as well. This great cache of data has
enormous implications for the study of bird ecology. Although it is a
relatively new platform and its temporal reach is limited, the taxonomic
and geographic breadth of eBird data will no doubt make it an important
tool in studying avian biology.</p>
<p>The goal of this project is to use eBird and meteorological data to
study the effect of local weather conditions on the arrival time of TGMs
in Massachusetts. To do this, we’ll download eBird’s species occurrence
data from the Global Biodiversity Information Facility (GBIF) using <a
href="https://www.gbif.org/tool/81747/rgbif"><code>rgif</code></a>, an R
package that permits access to GBIF’s application programming interface
(API). We’ll also compile weather using another R package,
<code>noaa</code> which contains functions that interact with <a
href="https://www.ncdc.noaa.gov/cdo-web/webservices/v2">NOAA’s National
Climatic Data Center’s API</a>.</p>
</div>
<div id="methods" class="section level1">
<h1>Methods</h1>
<p>Firstly, you should decide which species to study. We’ll limit this
to any 5 in this <a href="tgms.csv">list of TGMs</a> that make their way
to MA each spring. Once you have 5 species chosen, download the
occurrence data for these species using the <code>occ_data()</code>
function from <code>rgbif</code>.</p>
<div class="green">
<div class="row">
<div class="col-sm-2">
<a class="far fa-sticky-note fa-5x" style="color:#939681"></a>
<!-- regular style -->
</div>
<div class="col-sm-9">
<p>eBrid does indeed have its own API and R package (two actually,
<code>rebird</code> and <code>auk</code>). However, I find them rather
cumbersome and hard to work with. <code>auk</code> is especially so in
that it requires downloading and filtering through the entire eBird data
set when one only wants to work with just a few species. The developers
suggest workarounds, however, one may still spend many hours just
loading the initial data. Fortunately, eBird sends its data to GBIF and,
thus, <code>rgbif</code>, which allows species-level queries to the GBIF
API, is much easier to work with. Same data, fewer headaches.</p>
</div>
</div>
</div>
<p><br></p>
<div id="querying-gbifs-api" class="section level2">
<h2>Querying GBIF’s API</h2>
<p>Before we go too much further, let’s have a look at what
<code>rgbif</code> can do. Its most promising function for our work is
<code>occ_data()</code> which searches GBIF occurrences relatively
quickly. Let’s first load the packages we’ll need now and later (make
sure they’re installed!). Then, let’s query GBIF for the common raven, a
most spectacular bird, in the state of Maine (a most spectacular place)
and plot the occurrence lat/lon on a map of that state using
<code>ggmap</code> and <code>cowplot</code> functions. Here we restrict
the <code>occ_data()</code> search by specifying the scientific name
(<em>Corvus corax</em>), the state/province to Maine, the year as 2018,
and a limit of 200 records.</p>
<pre class="r"><code>library(rgbif)
library(tidyverse)
library(MuMIn)
library(rnoaa)
library(data.table)
library(ggmap)
library(usmap)
library(magick)#for examples
library(cowplot)#for examples
library(lme4) #for linear mixed effect models
library(car) #for LME anova testing
library(data.table) #for frollmean function (and others)

raven &lt;- occ_data(scientificName = &quot;Corvus corax&quot;, stateProvince=&quot;Maine&quot;, limit=200,year=2018)

#get the state of ME from ggmaps map data
ME&lt;- map_data(&#39;state&#39;, &#39;maine&#39;)

raven.p &lt;- ggplot(ME, aes(long,lat,group=subregion) )+
  geom_polygon(colour = &quot;gray&quot;,fill=&quot;gray90&quot;)+geom_point(data=raven[[2]],aes(x=decimalLongitude,y=decimalLatitude,size=individualCount),alpha=0.3,inherit.aes = F)+ coord_quickmap()+theme_void()

#and add image to the map with cowplot
raven.p2 &lt;- ggdraw() +
  draw_image(&quot;https://www.allaboutbirds.org/guide/assets/photo/63739491-480px.jpg&quot;,scale = 0.3,halign=0,valign=1) +
  draw_plot(raven.p)
print(raven.p2)</code></pre>
<div class="figure">
<img src="mod7_proj_files/figure-html/unnamed-chunk-1-1.png" alt="Fig. 1. Records for common raven in Maine, 2018." width="672" />
<p class="caption">
Fig. 1. Records for common raven in Maine, 2018.
</p>
</div>
<pre class="r"><code>knitr::opts_chunk$set(eval = FALSE)</code></pre>
<p>Notice how <code>occ_data()</code> returns records as a list of
different data types. See . . .</p>
<pre class="r"><code>names(raven)

lapply(raven,head)</code></pre>
<p>This includes the meta data (<code>$meta</code>), data about the data
and the data themselves, (<code>$data</code>), a tibble. The
<code>$data</code> tibble includes the information we need for this
project, including date, lat, long, count, etc. Thus, to access the
lat/lon data in our records, we refer to the second element in the list,
that is <code>raven[[2]]</code>.</p>
<p>Before we get a GBIF search for TGMs started, I suggest first storing
your species names in a vector (so please choose them and store them).
Say, for instance, you chose great-crested flycatcher, Baltimore oriole,
rose-breasted grossbeak, yellow-billed cuckoo, and black-throated blue
warbler. We also want to restrict the search to spring arrival time in
years of interest (i.e., those with decent eBird data . . . &gt;1990 or
so). Let’s store those values, too.</p>
<pre class="r"><code>species &lt;- c(&quot;Myiarchus crinitus&quot;,&quot;Icterus galbula&quot;,&quot;Pheucticus ludovicianus&quot;,&quot;Coccyzus americanus&quot;,&quot;Setophaga caerulescens&quot;)

y &lt;- paste0(&quot;1990&quot;,&quot;,&quot;,&quot;2023&quot;)
m &lt;- paste0(&quot;3&quot;,&quot;,&quot;,&quot;6&quot;)</code></pre>
<p>Notice how the year and month vectors, <code>y</code> and
<code>m</code>, respectively, are each a character string with two
values separated by a comma. This is how we’ll constrain the search with
<code>occ_data()</code>. Have a look at <code>?occ_data</code> to
familiarize yourself with the function’s parameters and the values they
take.</p>
<p>To commence the GBIF queries for your 5 species, I suggest using a
familiar convention: a <code>for</code> loop that passes data to an
empty list. That is, establish that empty list and run the species
through <code>occ_data()</code>, storing values in the list as the
<code>for</code> loop progresses. Here are some important pieces.</p>
<p>Constrain the <code>occ_data()</code> search by:</p>
<ul>
<li>each of your species in your loop
(i.e.,<code>scientificName=i</code> if <code>i</code> is your
<code>for</code> variable)</li>
<li>occurrences within our year and month range (<code>year=y</code> and
<code>month=m</code>)</li>
<li>occurrences in United States and the state Massachusetts
(<code>country="US"</code> and
<code>stateProvince="Massachusetts"</code>)</li>
<li>occurrence record should be based on a human observation, that is,
someone saw this in the wild (i.e., an eBird record,
<code>basisOfRecord = "HUMAN_OBSERVATION"</code>).</li>
</ul>
<p>This will be a rather labored search in that it might take 20 minutes
to run through all five species, depending on the number of records.
But, this is nothing like the hours one would spend working with
<code>auk</code>. So run this and grab a sandwich and refresh your
twitter feed. After that, we should have a many thousands of MA eBird
records loaded to the list.</p>
<p>To get get you started, here’s what could be done. But note, this
will take a while and it this is an <a
href="https://bcorgbio.github.io/class/mod5_proj.html#Analysis_Part_III:_Evolution_in_Parallel">embarrassingly
parallel</a> operation that could be done with multiple cores.</p>
<pre class="r"><code>dat.l &lt;-list()

for(s in species){
  
  ## setting the limit=0 returns no records but can give you the number of observations if you access the meta data
n.obs &lt;-  occ_data(scientificName = s,year=y,month=m,limit=0,country=&quot;US&quot;,basisOfRecord = &quot;HUMAN_OBSERVATION&quot;,stateProvince=&quot;Massachusetts&quot;)$meta$count 

print(n.obs)


dat.l[[paste0(s)]] &lt;- occ_data(scientificName = s,year=y,month=m,
                               limit=n.obs,country=&quot;US&quot;,
                               basisOfRecord = &quot;HUMAN_OBSERVATION&quot;,
                               stateProvince=&quot;Massachusetts&quot;)[[2]]


}

dat &lt;- rbindlist(dat.l,fill=T)

head(dat)</code></pre>
<p>Note that we store the number of observations for each species,
ripped from the meta data using <code>occ_data()</code> with
<code>limit=0</code>. This won’t return records, but will return the
meta data. We can then pass this number to <code>limit</code> in the
subsequent use of <code>occ_data</code> to bypass the limit of 500,
which is the default.</p>
<div class="green">
<div class="row">
<div class="col-sm-2">
<a class="far fa-sticky-note fa-5x" style="color:#939681"></a>
<!-- regular style -->
</div>
<div class="col-sm-9">
<p>This search will take a little while and we certainly don’t want to
repeat it any more than we have to. If the code that runs this lengthy
search is part of your markdown (and it probably should be!), simply set
the chunk options to <code>cache=TRUE</code>. So set, when this chunk
runs successfully, the <a
href="https://yihui.org/knitr/options/#cache">results are stored (i.e.,
cached) so they can be accessed without running the code again</a>. The
cache will be used in place of the chunk until the code within it
changes. Give it a shot.</p>
</div>
</div>
</div>
<p><br></p>
<p>After a large operation like this, it’s best to save the data. Many
in the R world prefer that large data objects be stored as serialized
files. The <code>saveRDS()</code> function is exactly what we need for
this. The following will save data as an R serialized file with the name
“mass.bird.data.RDS”.</p>
<pre class="r"><code>saveRDS(dat,&quot;massbird.data.RDS&quot;)</code></pre>
<p>Now, if your script or markdown should be interrupted (e.g., a crash,
freeze, etc.), you can access your data with <code>readRDS()</code>:</p>
<pre class="r"><code>library(tidyverse)
dat &lt;- readRDS(&quot;massbird.data.RDS&quot;)</code></pre>
<p>With a sense of how the bird data will be downloaded, let’s see what
sort of numbers we’ll be dealing with. These are year-by-year totals
from <code>occ_data()</code> searches for the 5 species above . . .</p>
<pre class="r"><code>dat%&gt;%
  group_by(year,species)%&gt;%
  summarise(count=sum(individualCount,na.rm = T))%&gt;%
  ggplot(aes(x=year,y=count,col=species))+geom_point()</code></pre>
<p>It looks like there’s not much data before 2000 for all species.
We’ll keep this in mind as we move forward. Now let’s move on to
compiling weather data.</p>
</div>
<div id="querying-noaas-ncdc-api" class="section level2">
<h2>Querying NOAA’s NCDC API</h2>
<p>As of late fall 2024, <code>rnoaa</code> is not maintained on the
CRAN repostitory, where most R packages reside for installation. This
under the promise that a replacement package would be released by the
authors soon after. Alas, no replacement. Fortunately, we can still
install <code>rnoaa</code> as long a we choose a different repository.
That is, use the R Open Science repo instead of CRAN.</p>
<pre class="r"><code>install.packages(&#39;rnoaa&#39;, repos = &#39;https://ropensci.r-universe.dev&#39;)</code></pre>
<p>Before we start using the <code>rnoaa</code> funcitons, let’s think
about what weather parameters and at which locations and time frames
we’ll compile data from. We’re studying TGMs so we probably want to look
at weather along the migration route. That is, weather in Massachusetts
may not be the best predictor of migration timing because migrants
arriving there have to fly through local weather conditions along the
way.</p>
<p>Because nocturnal long-distance migrators fly about 200 km<span
class="math inline">\(^{-d}\)</span> <span
class="citation">(Hall-Karlsson and Fransson 2008)</span>, we can
estimate that a bird that was 1000 km away from Massachusetts 5 days
before arrival and 2000 km away 10 days before arrive. With this in
mind, we can establish an assumed migration path from the Gulf of Mexico
and sample weather from locations that are close to these distances from
Massachusetts. If one draws a line from Mobile, AL on the Gulf Coast
(about 2000 km from MA) to Boston, MA, Charlotte, NC sits along that
line and half way along an assumed flight path (1000 km from MA). Thus,
these locations represent logical sampling locations for our weather
data.</p>
<p>NOAA’s NCDC identifies weather stations by unique ID codes. The
following vector, <code>sts</code>, represents the codes for stations in
Mobile, Charlotte, and Boston that have relatively complete data sets
for wind and temperature over our time frame (&gt;1990 or so).</p>
<p>Before we start using <code>rnoaa</code> to access NOAA’s NCDC API,
we have to establish a key, a token of sorts that identifies the user
and establishes a connection to the NCDC servers. Head on over to <a
href="https://www.ncdc.noaa.gov/cdo-web/token">this page on NOAA’s NCDC
site</a> to retrieve a token. It will require entering an email address,
to which the token will be sent. Copy the token (a string of random
letters and numbers) and paste it into the following where “token” is
indicated.</p>
<pre class="r"><code>options(noaakey = &quot;token&quot;)</code></pre>
<p>The R function <code>options()</code> sets global parameter values
for your R session. With <code>noaakey="token"</code>, you’re telling R
to pass this token string to any function that asks for
<code>noaakey</code>, that is, all the <code>rnoaa</code> query
functions.</p>
<pre class="r"><code>sts &lt;- c(
  &quot;GHCND:USW00013894&quot;, #Mobible, AL 2k away about 10 days away @200 km/day
  &quot;GHCND:USW00013881&quot;, #Charlotte, NC 1000 km away about 6 days away @200 km/day
  &quot;GHCND:USW00014739&quot; #Boston
)</code></pre>
<p>Now that we have the station codes identified and a token key
established, let’s query the the NCDC API with
<code>ncdc_stations()</code> to retrieve their exact location. Let’s
first see what this function returns using our Boston station ID.</p>
<pre class="r"><code>bos &lt;- ncdc_stations(stationid = &quot;GHCND:USW00014739&quot;)

print(bos)</code></pre>
<p>Notice that the data about this station is stored in the
<code>$data</code> table returned by <code>ncdc_stations()</code> This
means we can run all three of out stations through this function and
combine the rows to give us a table with all the station data. We’ll use
these data to map the station locations to visualize our weather
sampling locations. Let’s do that using <code>lapply()</code> and a few
other tricks to prepare the station data for mapping and use with other
<code>ncdc</code> functions.</p>
<pre class="r"><code>sta.d &lt;- bind_rows( #bind the rows
  lapply(sts,function(x) ncdc_stations(stationid = x)$data ) #use lapply to run through stations
  )%&gt;%
  mutate(usmap_transform(.,input_names = c(&quot;longitude&quot;,&quot;latitude&quot;),output_names = c(&quot;longitude.1&quot;, &quot;latitude.1&quot;)))%&gt;% #join transformation of lat/long for projection with usmap
  mutate(name=str_sub(name, -5,-4))%&gt;%#simplify the name column, grab just the state
  mutate(migr.day=c(10,5,0))%&gt;% #so we can look at wind speed 0, 5 or 10 days before arrive in boston
  separate(id,into = c(&quot;station.type&quot;,&quot;id&quot;))%&gt;%#need to cut station type out from station id number
        print()</code></pre>
<p>First, we surround <code>lapply()</code> with <code>dplyr</code>’s
<code>bind_rows()</code> so that the results of the
<code>lapply()</code> operation will be collapsed into a single table.
Within <code>lapply()</code>, we have that function work on our stations
vector, <code>sts</code>, using a short customized function that queries
NCDC station data with <code>ncdc_stations()</code> and returns the data
with <code>$data</code>.</p>
<p>Next, we join transformed lat/lon data from this table using
<code>usmap_tranform()</code> from the <code>usmap</code> package. We’ll
use this package to map the eastern US with our sampling locations and
this package uses a funky lat/long projection We then mutate the
<code>name</code> column in the table to contain just the state using
<code>str_sub()</code> from the <code>stringr</code> package loaded with
<code>tidyverse</code>. With <code>str_sub(name, -5,-4)</code>, we’re
mutating the name to contain the characters that are the 5th through 4th
from the end of the string, that is, the state. Then, we add a column
that reflects the assumed migration day away from Boston (10, 5, and 0
for AL, NC, and MA, respectively). This will be important later. Lastly,
we use <code>dplyr</code>’s <code>separate()</code> function to split
the station ID column into two separate columns,
<code>station.type</code> and <code>id</code>, essentially replacing the
<code>id</code> column with the station code minus the prefix that
represents station type. We’ll need station ID without this prefix for
later <code>ncdc</code> operations.</p>
<p>Now let’s plot these locations on a map of the eastern US. We’ll use
<code>usmap</code>’s <code>plot_usmap()</code> function for this as it
plays nice with <code>ggplot</code>. <code>plot_usmap()</code> allows
one to include regions of the US. For our purposes, we need the
northeast, south, and east north central regions, so we pass
<code>c(.northeast_region,.south_region,.east_north_central)</code> to
the <code>include</code> parameter. On top of this map, we add points
using our transform lat/long data in the <code>sta.d</code> tibble.
Let’s make the points big and color them by name (i.e., state). Then,
let’s add a label using the same color scheme and nudge the position of
the lable closer to the points. Lastly, we removed the legend because,
duh, the points are labeled</p>
<pre class="r"><code>plot_usmap(
  include = c(.northeast_region,.south_region,.east_north_central)
)+geom_point(data=sta.d,aes(x=longitude,y=latitude,col=name),size=5)+geom_label(data=sta.d,aes(x=longitude,y=latitude,col=name,label=name),size=5,nudge_x = 1e6*0.25)+theme(legend.position = &quot;none&quot;)</code></pre>
<p>Voila! Looks like our sampling locations align with a decent NE
migration path. Now let’s get the weather data from these stations
during the spring of the years we have decent eBird data for, since 2000
when we see an uptick in eBird data. For this we’ll use
<code>meteo_pull_monitors()</code> which returns a tidy tibble. Notice
we pass the <code>sta.d$id</code> column to this function and it
contains the station ID without the prefix.</p>
<pre class="r"><code>#no data returned
weather.d &lt;- meteo_pull_monitors(sta.d$id,date_min = &quot;2000-01-01&quot;)
head(weather.d)</code></pre>
<p>Also notice that this produces a series of messages that indicate
you’ve queried the NCDC API and downloaded cached files to a local
location.</p>
<p>We’ll be looking at fourish weather parameters, the minimum and
maximum temperature in tenths of <span
class="math inline">\(^o\)</span>C (<code>tmin</code>), average wind
velocity in m<span class="math inline">\(^{-s}\)</span>
(<code>awnd</code>), and direction of fastest 2-minute wind
(<code>wdf2</code>). With the weather and eBird data in place, we can
move on to preparing the data for analysis and the analysis itself.</p>
</div>
<div id="data-analysis" class="section level2">
<h2>Data Analysis</h2>
<div id="preparing-ebird-data" class="section level3">
<h3>Preparing eBird Data</h3>
<p>For our analysis, we’ll compute arrival time for each species by
finding the day that corresponds to when 25% of all the individuals have
arrived in a given year. This means that we’ll have to find the total
number of individuals that arrived over our spring time frame for each
year for each species. Once we have this in place, we can model the
arrival as a process that resembles are logistic curve. Logistic curves
are used to describe many processes in biology that take on an S-shaped
response: population and tumor growth, infectious pathogen spread in a
pandemic (!), and enzyme substrate binding (e.g., Hb-O<span
class="math inline">\(_2\)</span> association).</p>
<p>So let’s explore an example of the arrival as modeled logistically of
one species, <em>“Myiarchus crinitus</em>, in previously a developed
data set. For this and all our species we’ll use Julian day as the time
variable, simply the day of the year. Let’s compute that and then . . .
.</p>
<pre class="r"><code>mc&lt;- dat%&gt;%
  filter(species==&quot;Setophaga caerulescens&quot;)%&gt;%
  group_by(year)%&gt;%
  mutate(date=as.Date(paste0(year,&quot;-&quot;,month,&quot;-&quot;,day)),
         j.day=julian(date,origin=as.Date(paste0(unique(year),&quot;-01-01&quot;)))
  )%&gt;%
  group_by(species,year,j.day,date)%&gt;%
  summarise(day.tot=sum(individualCount,na.rm=T))%&gt;%
  group_by(species,year)%&gt;%
  mutate(prop=cumsum(day.tot/sum(day.tot,na.rm = T)))%&gt;%
  filter(year&gt;1999)

mc%&gt;%
  ggplot(aes(j.day,prop))+geom_point()+facet_wrap(year~.)</code></pre>
<p>So as we can see, arrival of these migrants follows a logistic
process when we consider the proportion of the population that has
arrived. Now we can model this with a logistic model in R. We’ll add
predictions based on <code>nls()</code> and <code>SSlogis()</code>
functions from the <code>stats</code> package. This is similar to
something we did in the project for <a
href="https://bcorgbio.github.io/class/mod3_proj.html#More_Complex_Visualizations_and_Models">Module
3</a>. A logistic model requires a few parameter: the asymptote
(<code>Asym</code>), the x value (<code>j.day</code> in our case) at the
inflection point of the curve (<code>xmid</code>), and the scale
(<code>scale</code>). We’ll use <code>SSlogis()</code>, a self-starting
model that creates initial estimates of the parameters. After modeling
the logistic curves, let’s add the date back to the tibble (it’ll be
important later) and then plot the predictions along with the original
data.</p>
<pre class="r"><code>mc.pred &lt;- mc%&gt;%
  group_by(year)%&gt;%
 summarize(
   pred=predict(nls(prop~SSlogis(j.day,Asym, xmid, scal)),newdata=data.frame(j.day=min(j.day):max(j.day))),#predict the logistic curve for each species
   j.day=min(j.day):max(j.day),
  )%&gt;%
  left_join(mc%&gt;%dplyr::select(j.day,date)) ## add date back to tibble


mc%&gt;%
  ggplot(aes(j.day,prop))+geom_point(aes=0.3)+geom_line(data=mc.pred,aes(x=j.day,y=pred),col=&quot;blue&quot;,size=2)+facet_wrap(year~.)</code></pre>
<p>Seems our logistic models for arrival of this species estimate the
arrival function really well. Now we’ll find the Julian day each year
that is closest to 0.25 of the population arriving. Let’s also plot how
this arrival day varies with year.</p>
<pre class="r"><code>mc.arrive.date &lt;-mc.pred%&gt;%
  group_by(year)%&gt;%
  filter(j.day==j.day[which.min(abs(pred-0.25))])

mc.arrive.date%&gt;%
  ggplot(aes(year,j.day))+geom_point()</code></pre>
<p>Pretty variable, so maybe weather can explain this. This is but just
one of five species. We’ll come back to running a similar analysis for
all five at once.</p>
</div>
<div id="preparing-weather-data" class="section level3">
<h3>Preparing weather Data</h3>
<p>Now let’s prepare our weather data. This first operation is rather
involved, so we’ll work through it step by step. First, we’ll have to
add columns for year and Julian day so that we can later join the
weather and eBird data. We’ll strip the year from the date column using
<code>str_sub()</code> and then group by year to compute the Julian day,
just as we did for the eBird data. We’ll also make sure that date is
stored as date-class data with <code>as.Date()</code>.</p>
<p>Notice that along with computing Julian day with a
<code>mutate()</code> operation, we also add columns for another date
(<code>date2</code>) and new weather data columns, <code>wdir.rad</code>
and <code>wvec</code>. We need to repeat the date column for a join
later that allows the dates between the eBird and weather data sets to
be offset by 0, 5, or 10 days according to the when we expected the
birds to move through AL and NC.</p>
<p>The <code>wdir.rad</code> column computes the wind direction in
radians based on <code>wdf2</code>, the wind direction for two minutes.
For this, we want to scale the direction to 180<span
class="math inline">\(^o\)</span>, so we take the absolute of the
difference from 180 and subtract that value from 180. Then we multiply
this value by <span class="math inline">\(\pi/180\)</span> to get
radians. Why are we doing this? See the note below.</p>
<p>With this same mutate function, we’ll compute the wind vector by
finding the <span class="math inline">\(cos\)</span> of the angle (in
radians), multiplying it by wind velocity (<code>awnd</code>), and
finally multiplying this value by -1. We flip the sign of the vector
because wind is recorded as <em>out of</em> a direction in degrees. See
the note below.</p>
<p>After this, we’ll select the weather columns we want to work with,
and then join the station tibble to this weather tibble. This will add
the migration timing data, that is, the <code>migr.day</code> column
that specifies how far back in time to look at weather in AL and NC.
Notice, using this value in another mutate, we change <code>j.day</code>
to reflect this shift. That is, <code>j.day</code> for AL and NC weather
will be 10 and 5 days behind the original <code>j.day</code> (the Julian
day of bird arrival, too.).</p>
<pre class="r"><code>weather.d &lt;- weather.d%&gt;%
  mutate(year=as.integer(str_sub(date,1,4)), #add year
         date=as.Date(date))%&gt;%
  group_by(year)%&gt;% #group by year so we can compute julian day
 mutate(j.day=julian(date,origin=as.Date(paste0(unique(year),&quot;-01-01&quot;))), #add julian day
  date2=date,
  wdir.rad=(180-abs(wdf2-180))*pi/180, #radians so we can use a trig function to compute wind vector, scale degrees first to 180 scale to 2x pi and subtract from 180 (wind comes out of a direction)
  wvec=cos(wdir.rad)*-1*awnd # we want a negative value for positive value for 2x pi
  )%&gt;% #store day in new column
  dplyr::select(id,year,date2,j.day,tmin,tmax,wvec)%&gt;% #select the rows we need
  left_join(sta.d%&gt;%select(id,name,migr.day))%&gt;% #add the station id info (ie. name)
  mutate(j.day=j.day+migr.day)#make j.day ahead of BOS according to the migration days away so we can join weather along path</code></pre>
<div class="green">
<div class="row">
<div class="col-sm-2">
<a class="far fa-sticky-note fa-5x" style="color:#939681"></a>
<!-- regular style -->
</div>
<div class="col-sm-9">
<p>So why scale the wind direction to 180<span
class="math inline">\(^o\)</span>? Because we care about the direction
relative to north only and we’re going to compute a vector—this is what
will matter. Have a look at these four wind directions in the table
below. Two winds coming out of the north at 10 and 350<span
class="math inline">\(^o\)</span> or south at 160 and 200<span
class="math inline">\(^o\)</span> have the same difference from 0<span
class="math inline">\(^o\)</span> or exactly north (Fig. 3:A). When
transformed to a 0-180<span class="math inline">\(^o\)</span> scale and
into radians, you can see from the table the values are the same within
each group. Now, when multiplied by a velocity, we’ll get a vector
relative to north as well. In this case, because wind direction is
reported as coming from a direction in degrees (rather than toward),
we’ll multiply the vector by -1 to establish a vector that, if negative,
represents a head wind and, if positive, represents a tailwind (Fig.
3:B).</p>
</div>
</div>
</div>
<p><br></p>
<p>Now, with the variables we want (arrival day on the bird side,
<code>tmin</code>, <code>tmax</code>, and <code>wvec</code> on the
weather side), we’re ready to join eBird and weather data for analysis.
To get you started, let’s join the the arrival data for <em>Myiarchus
crinitis</em> with our weather data. To this tibble, we’ll also join the
<code>date</code> column from the original bird data so we can see if
the weather data is the right number of days behind the bird arrive
date.</p>
<pre class="r"><code>mc.arr.weath &lt;- mc.arrive.date%&gt;%
  left_join(weather.d)%&gt;%
  left_join(mc%&gt;%dplyr::select(year,date,j.day))

head(mc.arr.weath)</code></pre>
<p>Sure enough, it is: <code>date2</code> from the weather data is 10
and 5 days behind for AL and NC locations, respectively. Here we have
the weather along the migration route with each of our stations and
their data identified by name. But, how are we to analyze the data?
Let’s think about the question (<strong>Does weather along the migration
route predict arrival time?</strong>). Do we want just one day of
weather at each location to predict arrival time (which the table above
gives)? Let’s dive deeper into the weather data and compute the mean
over two week (14 days) before a bird gets to each location. That is, at
200 km<span class="math inline">\(^d\)</span>, the table above assumes
that birds don’t stop. And, they certainly do to eat and rest <span
class="citation">(Moore and Kerlinger 1987)</span>.</p>
<p>So let’s assume that 5 and 10 days is the earliest they would arrive
at these weather locations, but it could be two weeks earlier. If that’s
the case, let’s calculate the mean of our weather variables over that
time period. For this, we’ll use a group and mutate using
<code>dplyr</code> and the <code>frollmean()</code> function from
<code>data.table</code> package. <code>frollmean()</code> computes a
rolling mean across the rows of a table, perfect for our application.
We’ll use it to compute the rolling mean for our weather variables for
two weeks preceding each Julian day. then join this weekly data tibble
to our arrival data for subsequent analysis. When we use
<code>left_join()</code>, only the Julian days in the weekly average
tibble matching those in the arrival data will be kept.</p>
<pre class="r"><code>weather.wk &lt;-weather.d %&gt;% 
  group_by(year,name) %&gt;% 
  mutate(wk.tmin = frollmean(tmin, n=14,align=&quot;right&quot;),
         wk.tmax = frollmean(tmax, n=14,align=&quot;right&quot;),
         wk.wvec = frollmean(wvec, n=14,align=&quot;right&quot;)
         )%&gt;%
  dplyr::select(j.day,date2,name,wk.tmin,wk.tmax,wk.wvec)

mc.arr.weath2 &lt;- mc.arrive.date%&gt;%
  left_join(weather.wk)

head(mc.arr.weath2)</code></pre>
<p>Notice that <code>frollmean()</code> needs <code>n</code> specified,
the number of values in adjacent rows (actually, n-1 rows) to compute
the mean. We’ll also specify that the function look to the right when
computing the mean, that is, each individual row and the preceding 13
rows in this case. Lastly, we chopped down the weekly average tibble to
relevant columns before joining it to the arrival data.</p>
<p>With two joined tibbles each containing eBird and weather data, we’re
finally ready for some analysis.</p>
</div>
</div>
<div id="linear-mixed-effect-modeling" class="section level2">
<h2>Linear Mixed-effect Modeling</h2>
<p>To evaluate the effect of weather parameters on arrival time, one
could undertake analysis using simple linear models. But, we have a
rather complicated data set, including parameters (i.e., covariates) we
see as important and explanatory that may contribute to a slope and
intercept of the model and others that may be the reason that some
groups within the data set have different slopes and intercepts. The
variables that contribute to the slope and intercept are termed fixed
effects, while those that contribute to distinct slopes and intercepts
are termed random effects, and thus an analysis that accounts for both
fixed and random effects is called a mixed effect model. In our case, we
are interested in how the fixed effects of temperature and wind vector
explains arrival and are OK with the fact that the location of these
weather variables (a random effect) may contribute differently to the
relationship. <strong>In subsequent analysis, you’ll also consider
species as a random effect, allowing the response of arrival time may
vary according to species.</strong></p>
<p>Undertaking linear mixed-effect analysis in R is rather
straightforward using the <code>lme4</code> package, specifically the
<code>lme()</code> function. Any formula for <code>lme()</code> is
similar to other model choices in R, except that we must specify a
random effect. This takes the form of <code>+(1|variable)</code> or
<code>+(y|variable)</code> where <code>variable</code> is a random
effect and <code>y</code> is the response. The first of these
constructions stipulates that the slope may vary according to the random
effect, while the second stipulates that the slope <em>and</em>
intercept may vary according to the random effect. With this in mind,
let’s kick the tires on linear mixed-effects models using
<code>lme()</code> with our two data tibbles, one with a single
weather-day sample and another with a two week-average of the
weather.</p>
<pre class="r"><code>#weather at 0, 5, and 10 days away from arrival
mc.lmer &lt;- lmer(j.day~tmin*tmax*wvec+(1|name),mc.arr.weath,na.action = &quot;na.fail&quot;)
Anova(mc.lmer) #Anova from the car package

#0Mean two week weather preceding arrival
mc.lmer2 &lt;- lmer(j.day~wk.tmin*wk.tmax*wk.wvec+(1|name),mc.arr.weath2,na.action = &quot;na.fail&quot;)
Anova(mc.lmer2) </code></pre>
<p>Notice that we specified the random effect of location using
<code>(1|name)</code>, allowing each location to have a separate effect
on the slope of the relationship between <code>j.day</code> and the
weather variable, <code>tmin</code>, <code>tmax</code>, and
<code>wvec</code>. Specifying a random effect on slope is usually
sufficient, especially for more complicated data sets. Notice also that
we included interactions between all the fixed effects with
<code>*</code>. As we’ve explored before, this is a good place to start,
assuming interactions. To assesses the significance of the fixed effects
we’ve used the <code>Anova()</code> function from the <code>car</code>
package that suits mixed-effect models. As you can see from running
<code>Anova()</code> over our two models, including only one day of data
at each location doesn’t reveal any significant relationships between
weather and arrival day; however, an analysis including a two-week
average at each location (offset to reflect the soonest a bird would
leave) does reveal significant fixed effects of weather.</p>
<p>Also have a look at the interactions at the end of the anova tables.
For analysis including two-weak averages of weather values, there is an
important interactions between the averages for <code>tmin</code>,
<code>tmax</code> and <code>mvec</code>, that is, the degree (i.e.,
slope) of response varies according all three weather values.</p>
<p>In keeping with one thrust of the course, any one model is just one
way to explain data and, thus, we should consider other models using our
model-choice framework. So let’s do that, dropping weather variables
from the two-week average analysis. With three variables, we have at
least 6 possible combinations when we include all the possible
interactions, if we so choose. Fortunately, the <code>dredge()</code>
from the <code>MuMIn</code> package allows one to decompose a model to
all the combinations of the terms, including interactions, and report
important model fit values (e.g., AICc, <span
class="math inline">\(\Delta\)</span>AIC, and AIC<span
class="math inline">\(_w\)</span>). We’ll ask <code>dredge()</code> to
consider the our weather variables only with
<code>fixed= c("wk.tmin","wk.tmax","wk.wvec")</code>.</p>
<pre class="r"><code>mc.arr.aic &lt;- dredge(mc.lmer2,fixed = c(&quot;wk.tmin&quot;,&quot;wk.tmax&quot;,&quot;wk.wvec&quot;),)

mc.kb &lt;- kable(mc.arr.aic[1:4,],caption = &quot;Fit values for nested models of the most complicated lme model&quot;)

kable_styling(mc.kb)

best.lmer &lt;-  lmer(j.day~wk.tmin+wk.tmax+wk.wvec+(1|name),mc.arr.weath2,na.action = &quot;na.fail&quot;)

Anova(best.lmer)</code></pre>
<p>Notice how <code>dredge()</code> return the ranks of the nested
models according to AIC metrics and that the interactions columns (all
with “:” between the terms) return <code>NA</code>, meaning they are not
included in the best-fit model. So our best-fit model was
<code>j.day~wk.tmin+wk.tmax+wk.wvec+(1|name)</code>. The last few lines
of this run that model and report the anova results.</p>
<p>To sum up this quick exploration of linear-mixed effects modeling for
this one species, a model that includes minimum and maximum temperature
and wind vector explains the data best and minimum temperature and wind
vector are significant predictors.</p>
</div>
<div id="additional-operations-and-analyses" class="section level2">
<h2>Additional Operations and Analyses</h2>
<p>Your task is to repeat data compilation and analysis for five species
of your choosing from this <a href="tgms.csv">list of TGMs</a>. The
analysis should include the following components:</p>
<ol style="list-style-type: decimal">
<li>An operation that retrieves data for your five species through
<code>occ_data()</code>. Keep the same values (i.e., state of MA during
April and May, in the years 2000-2023). This can be a <code>for</code>
loop, but you may want to explore using some parallel processing with
something like <code>mclapply()</code> for example.</li>
<li>Logistic modeling operations to predict arrival time (the Julian day
when 25% of the population has arrived) for each year and for each
species.</li>
<li>Operations that join offset single-day and two-week weather averages
with your occurrence data. Both weather data sets should include minimum
and maximum temperature and wind vectors (this will require operations
on the weather data before these joins).</li>
<li>Linear mixed-effect modeling of arrival day as it varies with these
weather variables for both weather data sets (single-day and two-week
average)</li>
<li>Model-testing operations of both data sets using
<code>dredge()</code>.</li>
<li>Anova testing of the best-fit models from both data sets.</li>
</ol>
</div>
</div>
<div id="project-report" class="section level1">
<h1>Project Report</h1>
<p>Please submit your report to your team GitHub repository as an .Rmd
document with HTML output that addresses the following questions:</p>
<ol style="list-style-type: decimal">
<li>Does arrival time vary according to temperature and wind variables
along migration route for TGMs migrating to MA?</li>
<li>If arrival time does vary with meteorological conditions, what role
will climate change potentially play in the population status of TGMs
arriving in MA during the spring?</li>
<li>How does your analysis contribute to, challenge, or refine previous
hypothesis concerning the role that climatic variables play in
long-distance migration in passerine birds?</li>
</ol>
<p>In answering these questions, be sure to use the visualization,
modeling, and model-assessments tools we’ve used in the course so
far.</p>
<p>The answers and narrative in your .Rmd should include the following
components:</p>
<ul>
<li>A YAML header that specifies HTML output, the authors, and a
bibliography named “BIOL3140.bib”. <strong>Submit this bibliography as
well!</strong></li>
<li>Sections including an introduction, methods, results, discussion,
author contributions, and references. Make sure that each, aside from
the references, includes one to two short paragraphs. Specifically:
<ul>
<li>Introduction: Frame the questions, indicating why they are
important, what background work has been done in this realm, and how you
will answer them. <strong>Please include at one reference to support the
summary of previous work.</strong> Note: this can be done easily by
refiguring the introduction to this project report.</li>
<li>Methods: Explicitly state how you answered the questions, including
a narrative of all the analyses both qualitative and quantitative.</li>
<li>Results: Include any appropriate figures or tables and a narrative
of the main results that are important to answering the questions.</li>
<li>Discussion: Succinctly declare how the results relate to the
question and how they compare to previous work devoted to the topic. In
addition, be sure to comment on the importance of your findings to the
broader topic at hand. <strong>Please include at least two references to
other relevant studies.</strong> Note: circling back to the introduction
will be helpful here.</li>
<li>Author contributions: Briefly outline what each team member
contributed to the project.</li>
<li>AI-use Statement: Briefly state how AI was used in the completion of
the report requirements.</li>
</ul>
<strong>Each team should push one report Rmd</strong> as
“Module7_TeamX.Rmd” where “X” is the each number. Please also submit
<strong>all associated files and data</strong> (e.g., .bibtex files,
.csv files, etc.). This means one team member should push the team’s
submissions to their team’s github directory, i.e., “Module7_Team1”, if
in Team 1. Please push your submission by 11:59 pm, Sunday, November
23rd.</li>
</ul>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent"
entry-spacing="0">
<div id="ref-askeyev2009earliest" class="csl-entry">
Askeyev, Oleg V, Tim H Sparks, and Igor V Askeyev. 2009. <span>“Earliest
Recorded Tatarstan Skylark in 2008: Non-Linear Response to Temperature
Suggests Advances in Arrival Dates May Accelerate.”</span> <em>Climate
Research</em> 38 (3): 189–92.
</div>
<div id="ref-both2006climate" class="csl-entry">
Both, Christiaan, Sandra Bouwhuis, CM Lessells, and Marcel E Visser.
2006. <span>“Climate Change and Population Declines in a Long-Distance
Migratory Bird.”</span> <em>Nature</em> 441 (7089): 81–83.
</div>
<div id="ref-hall2008far" class="csl-entry">
Hall-Karlsson, K Susanna S, and Thord Fransson. 2008. <span>“How Far Do
Birds Fly During One Migratory Flight Stage?”</span> <em>Ringing &amp;
Migration</em> 24 (2): 95–100.
</div>
<div id="ref-knudsen2011challenging" class="csl-entry">
Knudsen, Endre, Andreas Lindén, Christiaan Both, Niclas Jonzén,
Francisco Pulido, Nicola Saino, William J Sutherland, et al. 2011.
<span>“Challenging Claims in the Study of Migratory Birds and Climate
Change.”</span> <em>Biological Reviews</em> 86 (4): 928–46.
</div>
<div id="ref-moore1987stopover" class="csl-entry">
Moore, Frank, and Paul Kerlinger. 1987. <span>“Stopover and Fat
Deposition by North American Wood-Warblers (Parulinae) Following Spring
Migration over the Gulf of Mexico.”</span> <em>Oecologia</em> 74 (1):
47–54.
</div>
<div id="ref-newton2008ecology" class="csl-entry">
Newton, I. 2008. <em>The Ecology of Bird Migration</em>. Academic Press,
London.
</div>
<div id="ref-smith2005arrival" class="csl-entry">
Smith, Robert J, and Frank R Moore. 2005. <span>“Arrival Timing and
Seasonal Reproductive Performance in a Long-Distance Migratory
Landbird.”</span> <em>Behavioral Ecology and Sociobiology</em> 57 (3):
231–39.
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
