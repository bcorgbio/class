---
title: "Module 4 Project"
bibliography: class.bib
---
<style>
div.green { background-color:#c7d1c0; border-radius: 5px; padding: 20px;}
</style>

<!-- Add icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">

# Introduction

Now that we've learned (at breakneck speed!) some ins and outs of data analysis, visualization, and modeling, we'll turn to how a scientist can easily organize, share, and communciate results and ideas. Communication of the results of any research in scienec is, at its final stage, usually done through publishing scientific papers. However, before this final product, scientists must catalog the maturation of their work and often seek to repetedly share it with collaborators. Cataloging the progress and sharing preliminary results can take many forms: exchanging scripts that analyze data, giving presentations to colleagues, and passing manuscripts back and forth between team members, just to name a few activities. 

From a mechanistic standpoint, the workflow for sharing progress is often decentralized. Want to share scripts? Send the over email or store them in cloud (or GitHub!). Want to give a presentation? Import figures from your scripts into a slide deck. Want to create and share a manuscript? Write up in a word-processing software and disstrubute over email or the cloud. Fortnately, there exists a unifying alternative: markdowns, an easy-to-read and easy-to-write plain text format that's then converted any one of a variety of formats (slides, PDF, HTML, etc.). For we scientists working in R, we can use R Markdown, giving us the added benefit of adding code and the results of our code to text and commentary about our work. It's one stop shopping.

In this project, we'll learn the basics of R Markdown. Specifically, we'll learn how author documents that include code, the graphics that are produced from it, and stylistically pleasing text that place the results of our analysis in context.

<center>

[![Alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)

</center>

Our tasks will be to:

  1. Familiarize ourselves with the R Markdown framework.
  2. Author simple R Markdown.
  3. Run code within an R Markdown document.
  4. Add graphics (i.e., figures), images, tables and references to and R Markdown document. 
  5. Render (i.e., knit) this R Markdown into HTML and PDF documents.

# Set up

First of all, let's precisely define what we mean by a markdown, the syntaxt for R Markdown. Markdown is a very simple ``markup" language which creates documents with headers, images, references, pieces of code and so much more from plain text files. Becuase it's text based, the document can be rendered into many other file formats like HTML or PDF that will contain the organized content.

To get R Markdown up and running, you don't need to do much at all if you're using R Studio. You just need to open a new markdown document. The machinery for formatting the source text file is loaded with R Studio. All you have to do is open a new markdown document in R Studio: ``File > New File > R Markdown". Notice this opens a tab with a markdown template named "untitled.Rmd". The ".Rmd" extensions informs R Studio that this is a source file for markdown and thus it will treat it as such. 


<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">

In R4DS, you may have noticed a discussion about the difference between R Markdown and R Notebooks. Notebooks are merely more compact version of R Markdowns. R Notebooks permit direct interaction with R while producing a reproducible document. However, any R Markdown document can be used as a notebook, so we'll bypass R Notebooks for now, and focus on R Markdowns.

</div>
</div>
</div>
<br>

Keep this document open and ready to edit. But, before was start, let's estabish the context for authoring an R Markdown. Say, thinking back to the [Module 3 Project](mod3_proj.html), we wanted to report on some of our results, how we came to them, and what they mean. In that project, we found that ecomorph was an important predictor of the hindlimb-SVL relationship in anoles. Specifically, we used phylogenetic least quares ananlyis to assess this relationship under Brownian motion and OU models of trait evolution.

To assemble such a report, we should include sections that reflect the the progression of the anaylsis, each containing text, figures, captions, and references. Our sections should include an introduction, methods, results, conclusions, and a bibliography. Our tasks for this project will be taken on in this context: producing a succinct and reproducible report on the analysis of anole hindlimb evolution. Let's get started.

# The YAML Header

You'll see at the top of your new ".Rmd" file a header contained between two lines (`---`). This is the YAML header that specifies the the attributes of the markdown. By default it includes a title, author, date and type of file for your output. These are but a few of the formatting options and settings that could apply to the whole document. For now, let's just include these, altering them to reflect your specific needs. For instance:

```
---
title: "Anole Ecomorph Hindlimb Evolution"
author: John Doe, Jane Doe, and Salmon Roe
date: 22/Sep/2020
output: html_document
---

```

Below the YAML header is the space where you'll include text, code, etc. 

# Headers

When you start putting together the content of an .Rmd, you should consider adding sections almost immediately. This can serve as an outline for the document. Headers provide a way of heirarchichally organizing the document into sections that refelct an outline. These are indentified in the markdown by using one or several `#`. The more you use, the smaller the text and, presumably the less inclusive the header. That is, `#` is the biggest header and `##` is typically nested within a `#` header, and `###` is nested within a `##` header. For instance, this 

```
# Header 1

Text under Header 1

## Header 2

Text under Header 2

### Header 3

Text under Header 3

```
will produce this:

# Header 1

Text under Header 1

## Header 2

Text under Header 2

### Header 3

Text under Header 3


In your future project reports for Phase II and III of the class, you'll always want to include sections for an introduction, methods, results, conclusions, and bibliography. We'll organize the .Rmd accordingly, so please add those sections to your .Rmd. with a high-level header `#`.  We'll add nested subsections and text later.  



```{r "load the data",include=FALSE,echo=FALSE}
library(tidyverse)
library(ape)
library(nlme)
library(MuMIn)
library(geiger)
anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")

anole2 <- anole%>%
left_join(anole.eco)%>%
  filter(!Ecomorph%in%c("U","CH"))%>%
  na.omit()

anole.log <- anole2%>%
  mutate_at(c("SVL", "HTotal","PH","ArbPD"),log)


### phylogenetic GLS models

#PGLS under BM, no ecomorph
pgls.BM1 <- gls(HTotal ~SVL, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under BM, w ecomorph
pgls.BM2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")


#PGLS under OU, no ecomorph
pgls.OU1 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, w, ecomorph
pgls.OU2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#AIC operations
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylow.aicw <- aicw(anole.phylo.aic$AICc)

#add phylo-corrected residuals
anole.log <- anole.log%>%
  mutate(phylo.res=residuals(pgls.BM2))

#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=Ecomorph2,y=phylo.res)) +geom_boxplot() +stat_summary(fun=mean, geom="point", size=3)

print(p.eco.phylo)

```

# Adding Code with Chunks

Code you include in your .Rmd should be written in sections enclosed by three backwards apostrophes (```). These sections are known as code chunks and look like this:


<pre><code>```{r}
x<-1:100
mean(50)
```</code></pre>


You can insert code chunks with by selecting the "insert" icon at the top of the the tab or my keying in "command+option+i". 

<center>

![](insertchunk.png)

</center>

To run the chunk, your can  click on "run" tap and selection "Run Current Chunk" or insert your cursor in the chunk and key in "command+shift+return". 

<center>

![](runchunk.png)

</center>

The content inside the curly brackets (`{}`) controls the behavior of code chunk. In this case, we're telling R markdown that the code inside the chunk is to be interpreted with R. This is a handy place to control the output of the code chunk. Let's jump right into how you would include code in chunks from our relavent anole project. 

At first, you'll want to include a chunk that loads the libraries you intend to use in the .Rmd. This can be added to the very top of the document. Something that looks like this:

<pre><code>```{r,include=FALSE}
library(tidyverse)
library(ape)
library(nlme)
library(MuMIn)
library(geiger)
```</code></pre>

Notice here that we included a behavior to the chunk, specifically  `include=FALSE`. This prevents the code, and the results from appearing in the finished file. 

With a few exceptions, the logical place to include the code that produces analyses or figures is in the results sections. This is where the first output of the code will likely be relavent. So, under the results section, insert the following code chunks that establish the data we need and performs the initial analysis for PGLS.


<pre><code>```{r, "load the data"}
anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")
```</code></pre>

<pre><code>```{r, "join, filter, mutate to log"}
anole2 <- anole%>%
left_join(anole.eco)%>%
  filter(!Ecomorph%in%c("U","CH"))%>%
  na.omit()

anole.log <- anole2%>%
  mutate_at(c("SVL", "HTotal","PH","ArbPD"),log)
```</code></pre>

<pre><code>```{r, "PGLS models"}
### phylogenetic GLS models

#PGLS under BM, no ecomorph
pgls.BM1 <- gls(HTotal ~SVL, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under BM, w ecomorph
pgls.BM2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")


#PGLS under OU, no ecomorph
pgls.OU1 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, w, ecomorph
pgls.OU2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")
```</code></pre>

<pre><code>```{r, "AIC"}
#AIC operations
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylow.aicw <- aicw(anole.phylo.aic$AICc)
```</code></pre>

<pre><code>```{r, "add residuals"}
#add phylo-corrected residuals
anole.log <- anole.log%>%
  mutate(phylo.res=residuals(pgls.BM2))
```</code></pre>

  
<pre><code>``{r,"plot residuals", fig.cap="Boxplot of phylogenetically corrected hindlimb residuals versus anole ecomorph"}
#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=Ecomorph2,y=phylo.res)) +geom_boxplot() +stat_summary(fun=mean, geom="point", size=3)

print(p.eco.phylo)

```</code></pre>

Notice that for each chunk, we icluded some text. This identifies the chunk with a name or label, as R Markdown calls it. Each name must be unique. These names are useful especially when we render the document and any errors or warnings emerge. More on that later. 

Also notice that this last chunked named "plot residuals" has another parameter, `fig.cap`. This specifies a caption to produce under any figures. In communicating result through visualizations, figures or otherwise, it's **essential that you include a description** caption. The caption should include what going in the figure (e.g., type of plot, the axes, where the data come from). 


#Modifying Text

The basic syntax of a markdown language is oddly enough, formulated around mark up. This is similar to other mark up languages like HTML or ML in that it uses tags to define elements within a document. 





# Project Report

It's likely that your head is spinning: we've covered a ton of topics in the project. What's left to do is merely pick up the high points of what we've explored and apply these in a few relatively straightforward operations. 

Let's have your team explore some ecological data and how it effects hindlimb-SVL patterns. We'll not take the a priori ecomorph designations for granted, but rather assess if important ecological parameters of perch height (how high in the tree the anole resides) and the diameter of the perch predicts discrete patterns in the hindlimb-SVL relationship. We''l use the log-transformed values of these variables are contained in the `anole.log` tibble.

For this project report, write a script named "groupname_module3.R" and undertake the following operations.
  
  1. Combine the code above so that you can establish the `anole.log` data tibble.
  2. Using the log-transformed data, construct two simple linear models that assess the effect of perch diameter and height by including these as covariates in your models. Be sure to use `+` notation rather than `*`, assuming there is no interaction (there isn't, trust me!).
  3. Explore how both perch diameter and height effect the hindlimb-SVL relationship by plotting the residuals of your simple linear models against these covariates. This will require mutating a data tibble to include residuals from both models. Please produce two separate plots.
  4. Under a BM model of trait evolution and using the tree provided, construct phylogenetic least squares models of the hindlimb-SVL relationships that include the unique combinations of these two covariates, i.e,
  
    * A PGLS model with the hindlimb-SVL relationship + perch height
    * A PGLS model with the hindlimb-SVL relationship + perch diameter
    * A PGSL model with the hindlimb-SVL relationship + perch height + perch diameter
    
  5. Assess the fit of each of these three models using AICc and AICw and comment on (with comments in the script) whether one or both of the covariates is a significant predictor of hinglimb length in a phylogenetic context. 
  6. Produce a plot of your own design that concisely visualizes the effect of your covariate(s) on the hindlimb residuals of the best fitting PGLS model. 
  7. Submit your script to [this link](https://forms.gle/5iD9u1ZmL7M3oNRN8).


Submissions are due by 11:59 PM on Sunday, September 27th.

# References