<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Module 5 Project</title>

<script src="site_libs/header-attrs-2.28/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>





<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>

<link rel="stylesheet" href="style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">BIOL 3140</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="schedule.html">Schedule</a>
</li>
<li>
  <a href="at_a_glance.html">Calendar</a>
</li>
<li>
  <a href="WCRs.html">WCRs</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Projects
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Phase I</li>
    <li>
      <a href="phaseI_rubric.html">Phase I report guidlines</a>
    </li>
    <li>
      <a href="mod1_proj.html">Module 1 Project</a>
    </li>
    <li>
      <a href="mod2_proj.html">Module 2 Project</a>
    </li>
    <li>
      <a href="mod3_proj.html">Module 3 Project</a>
    </li>
    <li>
      <a href="mod4_proj.html">Module 4 Project</a>
    </li>
    <li class="dropdown-header">Phase II</li>
    <li>
      <a href="phaseII_rubric.html">Phase II report guidlines</a>
    </li>
    <li>
      <a href="mod5_proj.html">Module 5 Project</a>
    </li>
    <li>
      <a href="mod6_proj.html">Module 6 Project</a>
    </li>
    <li>
      <a href="mod7_proj.html">Module 7 Project</a>
    </li>
    <li class="dropdown-header">Phase III</li>
    <li>
      <a href="phaseIII_rubric.html">Phase III report guidlines</a>
    </li>
    <li>
      <a href="final_proj.html">Final Project</a>
    </li>
  </ul>
</li>
<li>
  <a href="https://github.com/orgs/bcorgbio/discussions">BIOL 3140 Discussion</a>
</li>
<li>
  <a href="https://bostoncollege.instructure.com/courses/1659476/gradebook">Grades on Canvas</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Peer Contribution Evaluations
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="peer_contributions.html">Peer Contribution Evaluation Guidelines</a>
    </li>
    <li>
      <a href="https://forms.gle/ATeFa9wsV1t4g27g6">Author Contribution Evaluation Form</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Module 5 Project</h1>

</div>


<style>
div.green { background-color:#c7d1c0; border-radius: 5px; padding: 20px;}
</style>
<!-- Add icon library -->
<p><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"></p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>Sharks are an ancient group of cartilaginous fishes in the class
Chondrichthyes, subclass Elasmobranchii, and subdivision Selachimorpha.
The selachians include over 500 species that are further placed in in
two superorders: Squalomorphii and Galeomorphii. Modern sharks
originated nearly 200 million years ago (<span class="citation">Grogan,
Lund, and Greenfest-Allen (2012)</span>) and, since then, have
diversified into nearly every major marine ecosystem. This evolutionary
success has been attributed to the diversity of their locomotor modes
and associated body shape (<span class="citation">Lauder and Di Santo
(2015)</span>,<span class="citation">Thomson and Simanek (1977)</span>).
A modest body of work devoted to the <a
href="https://en.wikipedia.org/wiki/Ecomorphology">ecomorphology</a> of
sharks has focused largely on caudal find shape as it relates to ecology
and locomotor modes (<span class="citation">Thomson (1976)</span>,<span
class="citation">Wilga and Lauder (2004)</span>). Sharks have a
heterocercal tail in which the caudal part of notochord flexes dorsally
and supports a large dorsal lobe of the fin, while, with more than a few
exceptions, the ventral lobe is small.</p>
<p><br> <br></p>
<center>
<p><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0944200620300581-gr1.jpg" alt="bull shark" width="400"/></p>
<p><br> <br></p>
(<b>A</b>) The phylogenetic relationships and systematic placement of
major groups of shark and (<b>B</b>) <span class="citation">Thomson and
Simanek (1977)</span>’s ecomorphological groups. Figure from <span
class="citation">Sternes and Shimada (2020)</span>.
</center>
<p><br> <br></p>
<p>In there seminal work on shark ecomorphology, <span
class="citation">Thomson and Simanek (1977)</span> put forth that there
were four shark morphotypes:</p>
<ol style="list-style-type: decimal">
<li>A group characterized by having a deep body, large pectoral fins, a
symmetrical caudal fin with a narrow peduncle (ie., base to the fin) and
high-aspect ratio. A white shark represents this group.</li>
<li>A group characterized by a body less deep then Group 1 and cadual
fin that is swept (ie., large heterocercal angle–the angle between the
upper and lower lobes of the fin). This group includes most carcharhinid
sharks such as the bull shark.</li>
<li>A group with a large head, blunt snout, a body that has anteriorly
placed pelvic fins and posteriorly placed dorsal and pelvic, and a
caudal fin with a low heterocercal angle and small ventral lobe.
Catsharks (family Scyliorhinidae) and dogfish (order Squaliformes)
represent this group.</li>
<li>A group characterized by a caudal fin with a higher aspect angle
similar to that of Group 2 but lacking an anal fin.</li>
</ol>
<center>
<table>
<tr>
<td>
<center>
<img src="https://earthlife.net/wp-content/uploads/What-Is-A-Elasmobranch-1280x718-1.webp" alt="bull shark" height="200"/><br />
<br> A white shark, <i>Carcharias carchardon</i>, typical of Group 1.
<br> <br>
</center>
</td>
<td>
<img style="height: 20px; width: 20px"/>
</td>
<td>
<center>
<img src="https://biogeodb.stri.si.edu/sftep/resources/img/images/species/95_8407.jpg" alt="bull shark" height="200"/><br />
<br> A bull shark, <i>Carcharhinus leucas</i>, typical of Group 2. <br>
<br>
</center>
</td>
</tr>
<br> <br>
<tr>
<td>
<center>
<img src="https://www.vichighmarine.ca/wp-content/uploads/2017/03/Spiny-Dogfishy-600x321.jpg" alt="bull shark" height="200"/><br />
<br> A dogfish of the genus <i>Squalus</i> typical of Group 3. <br>
</center>
</td>
<td>
<img style="height: 20px; width: 20px"/>
</td>
<td>
<center>
<img src="https://biogeodb.stri.si.edu/caribbean/resources/img/images/species/4437_2257.jpg" alt="bull shark" height="200"/><br />
<br> A kitefin shark, <i>Dalatias licha</i>, typical of Group 4. <br>
</center>
</td>
</tr>
</table>
</center>
<p><br> <br></p>
<p><span class="citation">Sternes and Shimada (2020)</span> used <a
href="https://en.wikipedia.org/wiki/Morphometrics#Landmark-based_geometric_morphometrics">geometric
morphometrics</a> and a <a
href="https://en.wikipedia.org/wiki/Principal_component_analysis">multivariate
analysis</a> to evaluate the groups proposed by <span
class="citation">Thomson and Simanek (1977)</span> and found that sharks
fell into one of two morphotypes (A and B). Their Group A was
characterized by an elongate body, posteriorly placed dorsal fin, and a
swept caudal while Group B was characterized by a deeper body,
anteriorly place dorsal fins, and a less swept caudal fin. <span
class="citation">Thomson and Simanek (1977)</span> suggested that the
shape of species in these two broad ecomorphs evolved due to differences
in ecological niche and <a
href="https://en.wikipedia.org/wiki/Fish_locomotion">locomotor
behavior</a>. Specifically, they posited that the species of elongate
Group A are typically <a
href="https://en.wikipedia.org/wiki/Demersal_fish">benthic</a> and swim
like eels whereas the deeper bodied species of Group B are often <a
href="https://en.wikipedia.org/wiki/Pelagic_fish">pelagic</a> and swim
like salmon or tunas.</p>
<center>
<p><img src="https://ars.els-cdn.com/content/image/1-s2.0-S0944200620300581-ga1_lrg.jpg" alt="bull shark" width="400"/></p>
<p><br> <br></p>
From <span class="citation">Sternes and Shimada (2020)</span> who found
sharks could be assigned two morphotype groups: A, elongate body,
posteriorly placed dorsal fin, and a swept caudal fin; B, deeper body,
anteriorly place dorsal fins, and a less swept caudal fin.
</center>
<p><br> <br></p>
<p>Although the work of <span class="citation">Thomson and Simanek
(1977)</span> and later <span class="citation">Sternes and Shimada
(2020)</span> points to interesting patterns in shark body-shape,
neither study explicitly studied the role habitat—that is, pelagic or
benthic—had in influencing the evolution body-shape evolution. In
particular, <span class="citation">Sternes and Shimada (2020)</span>
merely observed that their two groups with different body shapes often
varied in their habitat preference. In addition, <span
class="citation">Sternes and Shimada (2020)</span> made no explicit,
quantitative phylogenetic test of their patterns. This leaves open an
important question: <strong>Do pelagic and benthic sharks have
significantly different body shape?</strong> Subsequently, we might also
ask, <strong>Has the morphology of pelagic and benthic sharks evolveed
at the same rate?</strong> These are the questions we will take on in
this project.</p>
<p>To answer such a question requires that we essentially recapitulate
the <span class="citation">Sternes and Shimada (2020)</span> body-shape
data set using landmark-based <a
href="https://en.wikipedia.org/wiki/Morphometrics#Landmark-based_geometric_morphometrics">geometric
morphometrics</a>. This is a relatively straightforward, if tedious,
method of capturing shape variation in a group of interest. For this,
you’ll digitize 14 homologous landmarks on images of some 270 species of
sharks. Using the best practices in the field of geometric morphometrics
to align our landlandmakrs and extract shape information, we’ll assess
morphological disparity in a phylogenetic frame work between pelagic and
benthic sharks.</p>
</div>
<div id="methods" class="section level1">
<h1>Methods</h1>
<div id="image-acquisition" class="section level2">
<h2>Image acquisition</h2>
<p>A few decades ago, a morphometric project like this would require
visiting museums collections from around the world to take images of the
specimens and species of interest. In fact, this was a major part of
Prof. Kenaley’s PhD thesis, which included trips to natural history
collections in France, Denmark, Great Britain, Taiwan, Japan, Monaco,
New Zealand, and Australia. Ahhhhhh, the good ol’ days. Fortunately (or
unfortunately), travel to such wonderful places may be avoided several
resources exist that contain a trove of images of fish-like
vertebrates.</p>
<p>We’ll make use of shark images in the <a
href="https://www.fishbase.us/">FishBase</a> catalog: a clearing house
of all things fish that has amassed tons of data from the scientific
literature. Prof. Kenaley used the <code>rfishbase</code> package to rip
images of scientific drawings of sharks. This resulted in a cache of
images for the ~200 species included in a recent phylogeny of the
elasmobranchs (<span class="citation">Stein et al. (2018)</span>).</p>
</div>
<div id="species-list-and-phylogeny" class="section level2">
<h2>Species list and phylogeny</h2>
<p>Because we’ll be comparing body shape in sharks, this project is by
definition a comparative one and we’ll need a phylogeny for the group.
Fortunately a relatviely recent phylogenomic analysis of over 500
species of elasmobranchs (sharks + batoids) has been published by <span
class="citation">Stein et al. (2018)</span>. Unfortunately, there is
some phylogenetic discordance in this study. Specifically, when
researchers analyze phylogenetic relationships, they typically repeat
their analysis in a process known as <a
href="https://en.wikipedia.org/wiki/Computational_phylogenetics#Evaluating_tree_support">bootstrapping</a>.
In phylogenetics, bootstrapping is conducted using the columns of the
character matrix. Each pseudoreplicate contains the same number of
species (rows) and characters (columns) randomly sampled from the
original matrix, with replacement. A phylogeny is reconstructed from
each pseudoreplicate, with the same methods used to reconstruct the
phylogeny from the original data. This often results in a data set of
trees that have conflicting relationships—that is, phylogenetic
uncertainty—and this was the case for the <span class="citation">Stein
et al. (2018)</span> study. We’ll have to account for this in our
analysis. But, more later on . . .</p>
<p>In any case, we’ve used the taxa studied in this paper to find images
in FishBase and we’ll use <a href="data/shark_trees.nex">a tree file</a>
representing phylogeny for our comparative analysis.</p>
<center>
<p><br> <img
src="https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41559-017-0448-4/MediaObjects/41559_2017_448_Fig1_HTML.jpg?as=webp"
style="width:50.0%" /> <br></p>
The phylogenetic relationships of the elasmobranchs according the <span
class="citation">Stein et al. (2018)</span>.
</center>
<p><br></p>
</div>
<div id="geometric-morphometrics" class="section level2">
<h2>Geometric morphometrics</h2>
<p>As we learned in class and what you’ve been reading, researchers
interested in comparing shape change between species often use
landmark-based geometric morphometrics. A geometric morphometric study
such as ours generally follow these steps:</p>
<ol style="list-style-type: decimal">
<li>Data collection: select landmarks of interest, usually through
digitization of specimen images.</li>
<li>Data standardization: Make landmarks comparable across all
specimens, usually through superimposition.</li>
<li>Analysis: choose a statistical approach appropriate to the
questions.</li>
<li>Interpretation: use the outcome of the statistical analysis to
assess the original questions.</li>
</ol>
<div id="digitization-and-landmarking" class="section level3">
<h3>Digitization and landmarking</h3>
<p>Our shape analysis will be based on 14 landmarks placed on images of
shark bodies of our ~200 species. To landmarks on the body, we’ll follow
this generalize workflow below in the image analysis program FIJI (FIJI
is just imageJ).</p>
<br>
<center>
<img src="shark_points.png" style="width:70.0%" /> <br>
</center>
<p><br></p>
<p>You and your team should will be assigned about 20 of the ~200
species to outline. Images of these species can be accessed through <a
href="https://drive.google.com/drive/folders/1TYAzcMcH0u64OEqsuc61W97zIL7qLGWU?usp=sharing">this
directory</a>. First choose one of your species to work on. For each
species, start with what you think is the best image, that is, it has a
scale bar, the wings are not damaged, and the hindwing is most exposed.
Open that best image in Fiji.</p>
<p>After opening the photo, follow the steps below</p>
<ol style="list-style-type: decimal">
<li><p>Open a image.</p></li>
<li><p>Select the multipoint tool.</p></li>
<li><p>Digitize the 14 landmarks you see above.</p></li>
<li><p>Measure the XY positions of these points
(<code>cmd/ctrl+m</code>).</p></li>
<li><p>Select the macro tab and run the macro
(<code>cmd/ctrl+r</code>).</p></li>
<li><p>Save the results to the appropriate directory.</p></li>
<li><p>Close the results and image tab (don’t save the image).</p></li>
</ol>
This process is demonstrated here. <br> <br> <br>
<center>
<iframe width="460" height="315" src="https://www.youtube.com/embed/-yZu3FkJLzU" frameborder="0" allowfullscreen>
</iframe>
</center>
<p><br></p>
<p><strong>Note:</strong> For the first image you outline, you will have
to open the macro editor (“Plugins” <span
class="math inline">\(\rightarrow\)</span> “New” <span
class="math inline">\(\Macro\)</span>). Paste the script command from
below into the editor and save this new macro to an appropriate
directory, perhaps your cloned repo. You’ll want to access this later
(“Plugins” <span class="math inline">\(\rightarrow\)</span> “Edit”) so
that you automate this process.</p>
<pre><code>f = getTitle();
dir=getDirectory(&quot;Choose where to save data &quot;);
selectWindow(&quot;Results&quot;);
saveAs(&quot;Results&quot;, dir+f+&quot;_.csv&quot;);</code></pre>
<p>This script saves the results as a <em>tab-separated</em> text file
with filname as the image file name. <strong>This is super
important!!</strong> and how we’ll link the landmarks to a species.</p>
<p>After your team has completed landmarking the assigned species,
upload your text files to <a
href="https://drive.google.com/drive/u/1/folders/1-vbmHBqKywxq3Wxd8iA8Awf38xz4Glk5">this
directory</a>. Once all the data appear here, Prof. Kenaley will
evaluate the quality of the landmarks and do some post-processing if
required (i.e., file-name checks, quality, etc.). You can then download
<a href="data/class_out_data_f23.zip">these evaluated data</a> for shape
analysis.</p>
</div>
<div id="superimposition" class="section level3">
<h3>Superimposition</h3>
<p>After digitizing landmarks, we must remove the distracting variations
of size, orientation, and position that can vary between specimens and
thus add noisey variables in analysis of shape. This can be mitigated by
using a superimposition method. Generalized procrustes analysis (GPA) is
the superimposition method of choice nowadays. GPA removes the variation
of size, orientation, and position by superimposing the landmarks in a
common coordinate system. The landmarks for all specimens are optimally
translated, rotated, and scaled based on a least-squared estimation. The
first step is translation and rotation to minimize the squared and
summed differences (squared Procrustes distance) between landmarks on
each specimen. Then the landmarks are individually scaled to the same
units of centroid size. Centroid size is the square root of the sum of
squared distances of the landmarks in configuration to their mean
location. The translation, rotation, and scaling bring the landmark
configurations for all specimens into a common coordinate system so that
the only differing variables are based on shape alone. The new
superimposed landmarks can now be analyzed in multivariate statistical
analyses</p>
<p><img src="gpa.png" /></p>
<p>Once EFA is used to describe the shapes in a data set, one is left
with many variables to consider including all the descriptors of all the
ellipses that form the outlines. This could be many hundreds of
variables in a data set like ours. This is a serious <a
href="https://en.wikipedia.org/wiki/Multivariate_statistics">multivariate
problem</a>.</p>
</div>
</div>
<div id="analysis-part-i" class="section level2">
<h2>Analysis: Part I</h2>
<p>For such a problem, researchers usually turn to Principal Components
Analysis (PCA) whereby the very complicated suite of variables is
distilled into a set of fewer variables that describe the important
variance among the original variables. In a sense, PCA produces a series
of regressions, or vectors, that pass through the values of the original
variables. This operation is performed iteratively, with the first
vector (the first principal component, PC1), drawn through the variable
space that accounts for the most variance in the data set. After the
combination of variables forming PC1 is removed, a subsequent vector
(PC2) is drawn through another unique variable space that describes the
second most amount of variance. This continues until most of the
variance is captured, resulting in scores of PCs. The first two or
three, however, are usually enough to describe a health amount of
variance, say 90% or more.</p>
<p>To perform EFA and then PCA, we need only to turn to one R package,
<code>Momocs</code>. Let’s load this package and begin with an example
analysis that we can scale up on our full data set.</p>
<p>We can begin by reading in one of the outline text files,
Prof. Kenaley has already produced for 10 species of butterflies and
moths. Please <a href="lep_examples.zip">download these</a> to follow
along. You can unzip this directory and place it your project
directory</p>
<p>You can begin the full analysis on data collected by the whole class
by <a href="data/class_out_data_f23.zip">downloading this zipped
directory</a>, unzipping it, and placing it in your project
directory</p>
<pre class="r"><code>library(tidyverse)
library(Momocs)

f &lt;- list.files(&quot;data/class_out_data_f23&quot;,full.names=T)

out &lt;- read_csv(f[1]) %&gt;%
  as.matrix()

out %&gt;%
  list() %&gt;%
  Out() %&gt;%
  coo_flipx() %&gt;%
  stack()</code></pre>
</div>
<div id="analysis-part-ii" class="section level2">
<h2>Analysis: Part II</h2>
<p>Morphologival disparity</p>
</div>
<div id="analysis-part-iii" class="section level2">
<h2>Analysis: Part III</h2>
<p>Evolutionary rates</p>
<!-- Notice that we've found all the files in the "lep_examples" directory with `list.files()`, searching for the patter ".txt" and using the full filepath to make a loading the data in the directory possible. Next, we use `read_delim()` with `delim=\t` rather than `read_csv()` because FIJI outputs tab-delimited data. We save this outline as `out` after tranforming it to a matrix, the prefer format for `Momocs`. -->
<!-- In the next operation, we transform this matrix into an `Momocs` outline using `Out()`; however, `Out()` must take a list of matrices and therefore we pipe in the `list()` function first. Next, `coo_flipx()` is invoked to flip the outline about the x axis--remember that the origin of the image field is the upper left, not the lower left in the usual graphical representation. Lastly, `stack()` is invoked to visualize the outline. And here we have a forewing visualized. -->
<!-- Now, we will of course have hundreds of files to load and analyze with PCA. For this challenge we will the `vroom()` function in the `vroom` package. It can read in all our data, regardless of whether the data are tab- or comma-separated, an issue identified in class. We have the file paths stored in `f`, which can be passed through this function. -->
<!-- As was mentioned above, the `Out()` function prefers a list, so ~~we can work on the list established here to visualize our outlines.~~ we'll have to construct a list a little differently. -->
<!-- ```{r datlist2, results=FALSE,message=FALSE,eval=F} -->
<!-- #make a large df with vroom -->
<!-- out.df <- vroom::vroom(f, id = "filename",progress=F) -->
<!-- #make list -->
<!-- outs.l <- sapply(f,function(x) out.df %>% filter(filename==x) %>% select(X,Y) %>% as.matrix) -->
<!-- outs.l %>%  -->
<!--   Out() %>%  -->
<!--   stack() -->
<!-- ``` -->
<!-- Wonderful! Fore- and hindwings loaded for the 10 examples species. However, notice we have a few problems. First, both fore- and hindwing are included in the same data set. This confounds analyzing and comparing shape in fore- and hindwing separately, a major goal of this project. Second, the outlines are of arbitrary size due to how much of the pixel field they spanned in the photos and whether or not a scale in mm was set. Thus, this arbitrary size scale would confound shape analysis from the start. Let's take on fixing the hindwing-forewing issue first and, later, we'll tackle the size issue. -->
<!-- Fortunately, we know whether each outline comes from either a fore- or hindwing because we added these metadata to the file name. ~~Thus, we merely need to strip this information from the file name when loading the data in our `for` loop. Let's do that by modified the loop.~~ The `vroom()` function  stores filename data in a column as a way to identify data (we specified the name of this column with `id = `filename`. -->
<!-- ```{r datlist3, results=FALSE,message=FALSE,eval=F} -->
<!-- #make a large df with vroom -->
<!-- out.df <- vroom::vroom(f, id = "filename",progress=F) -->
<!-- #add wing info -->
<!-- out.df <- out.df %>%  -->
<!--   mutate(wing=gsub("XY_.+_(hindwing|forewing)\\..+","\\1",basename(filename))) %>%  -->
<!--   na.omit() -->
<!-- #make list -->
<!-- outs.l <- sapply(f,function(x) out.df %>% filter(filename==x) %>% select(X,Y) %>% as.matrix) -->
<!-- #extract wing info -->
<!-- wings <- gsub("XY_.+_(hindwing|forewing)\\..+","\\1",basename(names(outs.l))) -->
<!-- ``` -->
<!-- ```{r eval=FALSE,include=FALSE,eval=F} -->
<!-- saveRDS(outs.l,"lep_outline_data.RDS") -->
<!-- ``` -->
<!-- Here, we use a general regular expression function `gsub()`, which [finds a character string within a fuller string](https://www.programmingr.com/tutorial/gsub-in-r/) and replaces it. In this case, we've asked `gsub()` to find either "hindwing" or "forewing" by using "|" for the or part. We've also specified that these two strings will be after any string (`grep` ".") of any length (`grep` "+") and after the "_". They'll also appear before ".txt". Each wing descriptor is saved to a unique position in the list `wing.l`. -->
<!-- To store our wing descriptors within our outlines, we can access the `fac` option in `Out()` when transforming our list of matrices into a list of `Momocs` outlines. This `fac` option takes a list of named one-dimensional vectors, so we make a list with a name "wing" that has the unlisted values of `wing.l`. Let's save this newly labeled list of outlines as `outs`. -->
<!-- ```{r fac,eval=F} -->
<!-- outs <-  outs.l %>%  -->
<!--   Out(fac=list(wing=wings)) %>%  -->
<!--   coo_flipx() -->
<!-- ``` -->
<!-- Now we can invoke `Momocs` `tidy`-like `filter()` function to parse the outlines according to their wing. Let's do that and visualize each group with `stack()`. -->
<!-- ```{r wingfilter,message=FALSE,eval=F} -->
<!-- forewings <- outs %>%  -->
<!--   filter(wing=="forewing") -->
<!-- hindwings <- outs %>%  -->
<!--   filter(wing=="hindwing") -->
<!-- forewings %>%  -->
<!--   stack() -->
<!-- hindwings %>%  -->
<!--   stack() -->
<!-- ``` -->
<!-- Now that we have two lists of outlines ready for analysis, let's come back to our size issue. If we ran and EFA analysis on these outlines, most of the variance would be due to their arbitrary size differences. To address this, practitioners of shape analysis transform their shapes into a common coordinate space that removes size altogether. The method of choice for this is the [Procrustes transformation](https://en.wikipedia.org/wiki/Procrustes_analysis). This method superimposes the shapes by optimally translating, rotating and uniformly scaling the objects. That is, both the placement in space and the size of the shapes are freely adjusted so that they are the same size and the distance between the positions of the points constituting the shape is reduced. To align the shapes, the can be compared to an arbitrarily selected reference shape (referred to as ordinary Procrustes analysis) or the shapes can be aligned to an optimally determined mean shape (referred to as generalized Procrustes analysis). We'll perform the latter. -->
<!-- Fortunately, `Momocs` has just a function for generalize Procrustes superimposition, `fgProcrustes()`. Let's use this and visualize our results. But before we do, we must tackle another problem: our outlines have a variable number of coordinates, making it impossible for `fgProcrustes()` to minimize the distance between points in each outline (which would it choose?). So we'll just sample 100 of the points in each outline using `Momocs`'s `coo_interpolate()`. This function fits a spline with high resolution to all the shapes and extracts a determined number of points at equal intervals. We can easily find the number of coordinates in each each set of wings and use the minimum value as the number we'll sample with `coo_interpolate()`. this will minimize the amount of information we lose. -->
<!-- ```{r proc, results=FALSE,message=FALSE,eval=F} -->
<!-- fore.min <- forewings %>%  -->
<!--   coo_nb() %>%  -->
<!--   min() -->
<!-- forewings %>% -->
<!--   coo_interpolate(fore.min) %>%  -->
<!--   fgProcrustes() %>%  -->
<!--   stack() -->
<!-- hind.min <- hindwings %>%  -->
<!--   coo_nb() %>%  -->
<!--   min() -->
<!-- hindwings %>%  -->
<!--    coo_interpolate(hind.min) %>%  -->
<!--   coo_slide(id=1) %>%  -->
<!--    coo_align()  %>% -->
<!--   fgProcrustes() %>% -->
<!--   stack() -->
<!-- ``` -->
<!-- Now all that's left to do is perform the EFA and then we can move on to PC analysis. For this, all we have to do is pipe in the `Momocs` EFA function, `efourier()`. We'll do this and specify `norm=FALSE` for these [very arcane reasons](https://momx.github.io/Momocs/reference/efourier.html#details). -->
<!-- ```{r efour, results=FALSE,message=FALSE,eval=F} -->
<!-- forewings %>% -->
<!--   coo_interpolate(fore.min) %>%  -->
<!--    coo_align()  %>% -->
<!--   fgProcrustes() %>%  -->
<!--   efourier(norm=FALSE)  -->
<!-- hindwings %>%  -->
<!--    coo_interpolate(hind.min) %>%  -->
<!--    coo_align()  %>% -->
<!--   fgProcrustes() %>%  -->
<!--   efourier(norm=FALSE)  -->
<!-- ``` -->
<!-- Performing the PCA is just as easy. We just finally add `PCA()` with the pipe. We'll have the results in appropriately name variables. -->
<!-- ```{r PCA, message=FALSE, results=FALSE} -->
<!-- forewing.pca <- forewings %>% -->
<!--   coo_interpolate(fore.min) %>% -->
<!--    coo_align()  %>% -->
<!--   coo_slide(id=1) %>%  -->
<!--   fgProcrustes() %>%  -->
<!--   efourier(norm=T) %>%  -->
<!--   PCA() -->
<!-- hindwing.pca <-hindwings %>%  -->
<!--    coo_interpolate(hind.min) %>%  -->
<!--    coo_align()  %>% -->
<!--    coo_slide(id=1) %>%  -->
<!--   fgProcrustes() %>%  -->
<!--   efourier(norm=FALSE) %>%  -->
<!--   PCA() -->
<!-- ``` -->
<!-- We can visualize the PCA with `plot_PCA()`, which will, by default produce a biplot of the first two PCs, the amount of variance explained by each, and a representation of the morphoshape described by the PCs (the outlines in the background). -->
<!-- ```{r plotpca,message=F,eval=F} -->
<!-- forewing.pca %>%  -->
<!--   plot_PCA(title = "forewings") -->
<!-- hindwing.pca %>%  -->
<!--   plot_PCA(title = "hindwings") -->
<!-- ``` -->
<!-- Now we can move on to the comparative analysis. -->
<!-- ## Comparative analysis -->
<!-- Before we begin, Let's remind ourselves of the questions we're attempting to answer so that we can figure out exactly how to answer then. First, do hind- and forewings vary in their evolutionary rates? Second, do major groups of the Lepidoptera vary in their hind- and forewing evolvability? -->
<!-- For this first question, we can simply evaluate the evolutionary rate of our PC scores for the hind and forewings using a method of choice. For the second question, we can look at the evolutionary rates of our PC scores across our Lepidopteran tree. -->
<!-- First of all, as mentioned previously, we need a tree and fortunately we have one for these species. Indeed, the species choice for this project was based on those sampled in the @kawahara2019phylogenomics study. So let's load the tree you can [download here](lep_tree2.tre). Make sure it's in your project's directory. We'll use `read.tree()` from the `ape` package and plot it just to check things out. Notice `cex=0.1` to keep the tip labels small in the relatively large tree. -->
<!-- ```{r, tree,eval=F} -->
<!-- library(ape) -->
<!-- lep.tree <- ape::read.tree("lep_tree2.tre") -->
<!-- plot(lep.tree,cex=0.1) -->
<!-- ``` -->
<!-- Looks great; however, the convention is for the root of the tree to be positioned in the upper left. This is easy to fix with `ape`'s `laddersize()` function. We'll also remove the pesky underscore between names in the tip labels. This will help with joining the tree data with our species data. -->
<!-- ```{r treefix,eval=F} -->
<!-- lep.tree <- ladderize(lep.tree) -->
<!-- plot(lep.tree,cex=0.1) -->
<!-- lep.tree$tip.label <- gsub("_"," ",lep.tree$tip.label) -->
<!-- ``` -->
<!-- Now that we have our PCA data and a tree of species, we need to a add species information (e.g., the species, higher taxonomic information, etc.) to the shape data so the tree and shape data can work together. Notice that each species is represented in the `outs` list (from whence our PCA is derived) by the file name that belongs to its outline. Let's look at their names. -->
<!-- ```{r names,eval=F} -->
<!-- basename(names(outs))[1:5] -->
<!-- ``` -->
<!-- Not a bit of species data. However, Prof. Kenaley has stored the filenames of each species in a table you can [download here](lep_image_data.csv). Have a look. -->
<!-- ```{r sptab,eval=F} -->
<!-- lep.sp <- read_csv("lep_image_data.csv") -->
<!-- head(lep.sp) -->
<!-- ``` -->
<!-- Have a look at the column "identifier". -->
<!-- ```{r ident,eval=F} -->
<!-- head(lep.sp$identifier) -->
<!-- ``` -->
<!-- This is the vector of the image file names minus the extension (.jpg, .png, etc.). Notice that our outline names, rather than species, contain this information--you saved the FIJI results as "XY_filename_hindwing.txt" or "XY_filename_forewing.txt". That is, this very same identifier in the species table is buried in the names of our outline data. So let's make a new tibble that strips the same identifier from the outline names and join the species data to this new tibble. -->
<!-- **NOTE**: We've now added `.csv` to the gsub command. -->
<!-- ```{r, outdata,eval=F} -->
<!-- out.data <- tibble(xy.file=basename(names(outs))) %>%  -->
<!--   mutate(identifier=gsub("XY_|_hindwing|_forewing|.txt|.csv","",xy.file)) %>%  -->
<!--   left_join(lep.sp) -->
<!-- head(out.data) -->
<!-- ``` -->
<!-- With this tibble in place, we can now add species information to our PCA data. The PC scores are stored in the the variable `x`, so we can summon them this way. Notice that the row names correspond to the outline file names, a column in out `out.data` tibble.  -->
<!-- ```{r pcsores,eval=F} -->
<!-- head(hindwing.pca$x,1) -->
<!-- head(forewing.pca$x,1) -->
<!-- ``` -->
<!-- Let's now join the species information in our `out.data` tibble to the PCA data, storing these in new variables.  -->
<!-- ```{r pca2,eval=F} -->
<!-- hindwing.pca2 <-  tibble(xy.file=basename(rownames(hindwing.pca$x)),PC1=hindwing.pca$x[,1],PC2=hindwing.pca$x[,2]) %>%  -->
<!--   left_join(out.data) -->
<!-- forewing.pca2 <-  tibble(xy.file=basename(rownames(forewing.pca$x)),PC1=forewing.pca$x[,1],PC2=forewing.pca$x[,2])%>%  -->
<!--   left_join(out.data) -->
<!-- ``` -->
<!-- Now we have the first 2 PCs for each wing stored with species information and are now ready for comparative analysis. -->
<!-- ## Evolutionary rates -->
<!-- There are several methods available to comparative biologist to estimate the rates of morphological evolution over a phylogenetic tree. We'll be using @o2006testing's method, the so-called "noncensored test" which uses the entire varian-cecovariance matrix (established by the a phylogeny) to calculate the likelihood of rates accross the tree. In this approach, one ancestral state is estimated under Brownian motion for the entire tree and the the optimal rate parameter values are estimated numerically until the likelihood of the model is maximized. This method is captured in the R package `phytools` with the function `brownie.lite()`.  -->
<!-- `brownie.lite()` takes two important arguments, a tree and the phenotypic values for each tip in the tree. ~~Let's take our tree and drop any tips that don't occur in our PCA data.~~ Let's take our tree and keep only the tips are in our PCA data and PCA data that are in the tree. -->
<!-- ```{r, tree2,eval=F} -->
<!-- keep <- intersect(unique(out.data$species),lep.tree$tip.label) #sp in both tree and data -->
<!-- lep.tree2 <- keep.tip(lep.tree,keep) -->
<!-- plot(lep.tree2,cex=0.1) -->
<!-- ``` -->
<!-- Here we only include `lep.tree` tip labels that are in the unique species values of our `out.data` variable. Then we use `ape`'s `drop.tip()` function to drop the tips in our tree that don't occur in our `out.data` tibble. -->
<!-- The phenotypic data passed to the `x` argument must be a named vector of values, so let's establish that for PCs 1 and 2, for both the hind- and forewings. -->
<!-- ```{r brownie1,eval=F} -->
<!-- #PC1s -->
<!-- hind.pc1 <- hindwing.pca2 %>%  -->
<!--     filter(species%in% lep.tree2$tip.label) %>%  -->
<!--   group_by(species) %>%  -->
<!--   summarize(PC1=mean(PC1)) %>%  -->
<!--   pull -->
<!-- names(hind.pc1) <-  hindwing.pca2%>%  -->
<!--     filter(species%in% lep.tree2$tip.label) %>%  -->
<!--   group_by(species) %>%  -->
<!--   summarize(PC1=mean(PC1)) %>%  -->
<!--   pull(species) -->
<!-- fore.pc1 <- forewing.pca2 %>%  -->
<!--     filter(species%in% lep.tree2$tip.label) %>%  -->
<!--    group_by(species) %>%  -->
<!--   summarize(PC1=mean(PC1)) %>%  -->
<!--   pull(PC1) -->
<!-- names(fore.pc1) <-  forewing.pca2 %>%  -->
<!--   filter(species%in% lep.tree2$tip.label) %>%  -->
<!--      group_by(species) %>%  -->
<!--   summarize(PC1=mean(PC1)) %>%  -->
<!--   pull(species) -->
<!-- #PC2s -->
<!-- hind.pc2 <- hindwing.pca2 %>%  -->
<!--     filter(species%in% lep.tree2$tip.label) %>%  -->
<!--   group_by(species) %>%  -->
<!--   summarize(PC2=mean(PC2)) %>%  -->
<!--   pull(PC2) -->
<!-- names(hind.pc2) <-  hindwing.pca2%>%  -->
<!--     filter(species%in% lep.tree2$tip.label) %>%  -->
<!--   group_by(species) %>% -->
<!--   summarize(PC2=mean(PC2)) %>%  -->
<!--   pull(species) -->
<!-- fore.pc2 <- forewing.pca2 %>%  -->
<!--     filter(species%in% lep.tree2$tip.label) %>%  -->
<!--    group_by(species) %>%  -->
<!--   summarize(PC2=mean(PC2)) %>%  -->
<!--   pull(PC2) -->
<!-- names(fore.pc2) <-  forewing.pca2 %>%  -->
<!--   filter(species%in% lep.tree2$tip.label) %>%  -->
<!--      group_by(species) %>%  -->
<!--   summarize(PC2=mean(PC2)) %>%  -->
<!--   pull(species) -->
<!-- ``` -->
<!-- Notice here that we filtered the PCA data to include only species that occur in our new, pruned tree. That is, tree species may be in the the PCA data, but species in the PCA data may not be in the tree. This is because some species queried in GBIF were returned as [synonyms](https://en.wikipedia.org/wiki/Synonym_(taxonomy)) under different valid taxonomic names. We won't worry about this now except to exclude these species as we have above and forge ahead.  -->
<!-- ```{r brownie2,eval=F} -->
<!-- library(phytools) -->
<!-- forePC1.BM<-brownie.lite(lep.tree2,fore.pc1*10) -->
<!-- hindPC1.BM<-brownie.lite(lep.tree2,hind.pc1*10) -->
<!-- forePC2.BM<-brownie.lite(lep.tree2,fore.pc2*10) -->
<!-- hindPC2.BM<-brownie.lite(lep.tree2,hind.pc2*10) -->
<!-- ``` -->
<!-- Also notice here that we multiplied our tip values by an arbitrary 10 units. This is because this [algorithm stumbles](http://blog.phytools.org/2011/12/error-message-from-brownielite-and.html) when tip branches are short and tip values are small. Great, now we have evolutionary rate estimates of wing shape stored in each variable under `sig2.single`. -->
<!-- ```{r singlerate,eval=F} -->
<!-- forePC1.BM$sig2.single -->
<!-- ``` -->
<!-- ```{r singlerate2, include=FALSE, eval=FALSE,eval=F} -->
<!-- hindPC1.BM$sig2.single/forePC1.BM$sig2.single -->
<!-- ``` -->
<!-- With these values stored we can compare the evolutionary rate for the first and second PCs between fore- and hindwings, something you should do in your report. -->
<!-- <!-- ## Shifts in evolutionary rates -->
<p>–&gt;</p>
<!-- <!-- We are also seeking to answer whether major groups of the Lepidoptera have undergone significant changes in the rate of wing-shape evolution. `brownie.lite()` can do this, but this method tells the practitioner nothing about the sign of the rate shife, i.e, whether the shift was to a slower or faster rate. For this, we'll use another method, phylogenetic ridge regression [@kratsch2014ridgerace]. This approach  takes a tree and a vector of tip data phenotypes, calculates the ancestral states at each node in the tree, and produces a regression line through each path in the tree, from root to tip including from each deeper node to a daugter node. The regressions are based on the phenotype values at each node vs. time between nodes and along path. The value of the slope parameter of these regressions is the rate. From this, we have rate vectors, i.e, changes in rate.  -->
<p>–&gt;</p>
<!-- <!-- To implement ridge regression, we'll turn to the `RRphylo` package written by @castiglione2018new.  Like, `brownie.lite()` the function `RRphylo()` takes a tree and tip data as argurment. For instance, here we compute the rates along the branches for hingwing PC1. -->
<p>–&gt;</p>
<!-- <!-- ```{r RR} -->
<p>–&gt; <!-- <!-- library(RRphylo) --> –&gt;</p>
<!-- <!-- hindPC1.RR <- RRphylo(tree=lep.tree2,y=hind.pc1) -->
<p>–&gt;</p>
<!-- <!-- ``` -->
<p>–&gt;</p>
<!-- <!-- ```{r duptips,eval=FALSE,include=FALSE} -->
<p>–&gt; <!-- <!-- tibble(sp=names(fore.pc1)) %>%  --> –&gt;
<!-- <!--   mutate(in.tree=sp%in%lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!--   filter(!in.tree) --> –&gt;
<!-- <!-- tibble(sp=lep.tree3$tip.label) %>%  --> –&gt;
<!-- <!--   mutate(in.tree=sp%in%names(fore.pc1)) %>%  --> –&gt;
<!-- <!--   filter(!in.tree) --> –&gt;</p>
<!-- <!-- all(!duplicated(lep.tree2$tip.label)) -->
<p>–&gt;</p>
<!-- <!-- ``` -->
<p>–&gt;</p>
<!-- <!-- The output of `RRphylo()` is massive, including the rates computed for each branch in the tree. -->
<p>–&gt;</p>
<!-- <!-- ```{r} -->
<p>–&gt; <!-- <!-- hindPC1.RR$rates --> –&gt; <!-- <!-- ``` -->
–&gt;</p>
<!-- <!-- Because we're interested in rate shifts, we use the rates from `RRphylo()` to tests whether individual clades evolve at different rates as compared to the rest of the tree. This is performed with `RRphylo`'s `search.shift()`. Here we specify that we want to know if any clades/lineages have exceptional rate shifts with `status.type="clade"`. The singles clades with exception shifts are stored in `single.clade`, only the p value of the shift. Large rates are significantly larger than the rest of the tree (at alpha = 0.05), when the probability is > 0.975; and small rates are significantly small for p < 0.025. -->
<p>–&gt;</p>
<!-- <!-- ```{r} -->
<p>–&gt;
<!-- <!-- hindPC1.SS<- search.shift(RR=hindPC1.RR,status.type="clade") -->
–&gt;</p>
<!-- <!-- hindPC1.SS$single.clades -->
<p>–&gt; <!-- <!-- ``` --> –&gt;
<!-- <!-- With this information we could visualize the nodes with exceptional shifts using `ape`'s `nodelabels` function. We merely need to plot the tree and take the numeric values of the row names returned in `single.clades`. -->
–&gt;</p>
<!-- <!-- ```{r viznodes} -->
<p>–&gt; <!-- <!-- plot(lep.tree2) --> –&gt;
<!-- <!-- nodelabels(node = as.numeric(rownames(hindPC1.SS$single.clades)),text = rownames(hindPC1.SS$single.clades)) -->
–&gt; <!-- <!-- ``` --> –&gt;</p>
<!-- <!-- This is fine, but `RRphylo`'s `plotShift()` does this for us. It's a little odd, but this function stores a plot in `plotClades()`, rather than produce a plot. -->
<p>–&gt;</p>
<!-- <!-- ```{r plotshifts} -->
<p>–&gt;
<!-- <!-- hindPC1.plot <- plotShift(RR=hindPC1.RR,SS=hindPC1.SS) -->
–&gt;</p>
<!-- <!-- forePC1.plot <- plotShift(RR=hindPC1.RR,SS=hindPC1.SS) -->
<p>–&gt; <!-- <!-- hindPC1.plot$plotClades() --> –&gt; <!-- <!-- ``` -->
–&gt;</p>
<!-- <!-- From the `single.clades` output and the tree labeled with `nodelabels`, we see that clade 36 represents a signifcant slow down, shifting -0.0034 units, but in clade 33 there's a signifant increase of 0.0053 units.  -->
<p>–&gt;</p>
<!-- <!-- Seems we've answer part of the question at least as it pertains to hindwing PC1 and our limited sample of species, "Have there been shifts in wing shape evolution in Lepidopteran lineages?" -->
<p>–&gt;
<!-- <!-- But, which lineage have shifted? We know which species belong to these lineages, but not the lineage name. -->
–&gt;</p>
<!-- <!-- To extract this information and view it on the tree, let's use a custom function, one written by Prof. Kenaley. For this, we'll need `ggtree`, a tree annotation package written to work with trees like `ggplot2` works with data and standard plots. We'll have to download `ggtree` rom the `Bioconductor` repository, another place where packages are stored, much like `CRAN`. To do this, run the following only **ONCE**: -->
<p>–&gt;</p>
<!-- <!-- ```{r ggtree, eval=FALSE} -->
<p>–&gt; <!-- <!-- if (!require("BiocManager", quietly = TRUE)) -->
–&gt; <!-- <!--     install.packages("BiocManager") --> –&gt;</p>
<!-- <!-- BiocManager::install("ggtree") -->
<p>–&gt; <!-- <!-- ``` --> –&gt;</p>
<!-- <!-- We'll also need the `wesanderson` package for nice colors which can be downloaded from `CRAN`. -->
<p>–&gt;</p>
<!-- <!-- ```{r ggtre, message=FALSE} -->
<p>–&gt; <!-- <!-- library(ggtree) --> –&gt;
<!-- <!-- library(wesanderson) --> –&gt;</p>
<!-- <!-- plot_SS <- function(tre=NULL,SS=NULL,tax=NULL){ -->
<p>–&gt;</p>
<!-- <!--   nodes <- as.numeric(rownames(SS$single.clades)) -->
<p>–&gt;</p>
<!-- <!--   pal <- wes_palette("Zissou1",n=length(nodes)) -->
<p>–&gt; <!-- <!--   sp <- list() --> –&gt;
<!-- <!--   for(i in nodes){ --> –&gt;
<!-- <!--     sp.i <- extract.clade(tre,i)$tip.label --> –&gt;</p>
<!-- <!--     #print(head(tax)) -->
<p>–&gt;
<!-- <!--     sub.names <- lapply(tax,function(x) x[x%in%sp.i])  -->
–&gt;</p>
<!-- <!--     in.clades <- lapply(sub.names,function(x) length(x)>0)  -->
<p>–&gt;
<!-- <!--     all.of.clade <- lapply(sub.names,function(x) all(sapply(sp.i,function(z) z%in%x)))  -->
–&gt;</p>
<!-- <!--     high.clade <- names(sub.names)[last(which(all.of.clade==T))] -->
<p>–&gt;
<!-- <!--     all.clades <- names(sub.names)[which(in.clades==T)] -->
–&gt; <!-- <!--     crown <- "" --> –&gt;
<!-- <!--     if(high.clade!=last(names(sub.names))) crown <- "crown-" -->
–&gt;</p>
<!-- <!--     sub.clades <- NULL -->
<p>–&gt;
<!-- <!--     if(length(grepl("oidea",all.clades))>0) sub.clades <- all.clades[grepl("oidea",all.clades)] -->
–&gt;</p>
<!-- <!--     high.clade2 <- paste0(crown,high.clade,": ",paste0(sub.clades,collapse = "+")) -->
<p>–&gt;
<!-- <!--     sp[[paste0(i)]] <- tibble(n=i,species=sp.i,clade=high.clade2) -->
–&gt;</p>
<!-- <!--   } -->
<p>–&gt;</p>
<!-- <!--   d <- do.call(rbind,sp)%>%  -->
<p>–&gt; <!-- <!--     rename(label=species)  --> –&gt;</p>
<!-- <!--   d2<- d %>% rename(clade_name=clade)  -->
<p>–&gt;</p>
<!-- <!--   p <- ggtree(tre)+ scale_y_reverse() -->
<p>–&gt;</p>
<!-- <!--   p$data <- p$data %>% left_join(d) %>% left_join(tibble(node=nodes,SS$single.clades) %>% mutate(shift=ifelse(rate.difference>0,"+","-"))) -->
<p>–&gt;</p>
<!-- <!--   p <-  p+geom_tiplab(aes(col=clade),geom="text",size=1.2)+ -->
<p>–&gt;
<!-- <!--     geom_cladelab(data=d2,mapping=aes(node=n,col=clade_name,label=clade_name),offset=1,size=1.5)+ -->
–&gt;
<!-- <!--     geom_hilight(data=d2,mapping = aes(node = n,fill=clade_name),alpha = 0.01)+ -->
–&gt; <!-- <!--     scale_fill_manual(values = pal)+ --> –&gt;
<!-- <!--     scale_color_manual(values = pal)+ --> –&gt;
<!-- <!--     theme(legend.position = "none")+geom_nodepoint(mapping=aes(subset = shift =="-"), size=5, shape=25,fill='blue',color='blue',alpha=0.7)+ -->
–&gt;
<!-- <!--     geom_nodepoint(mapping=aes(subset = shift =="+"), size=5, shape=24, fill='red',color='red',alpha=0.7) -->
–&gt; <!-- <!--   p <- p+xlim(NA,6) --> –&gt;
<!-- <!--   res <- tibble(n=nodes,SS$single.clades) %>% left_join(d %>% select(n,clade) %>% unique) -->
–&gt;</p>
<!-- <!--   return(list(plot=p,res=res)) -->
<p>–&gt;</p>
<!-- <!-- } -->
<p>–&gt;</p>
<!-- <!-- ``` -->
<p>–&gt;</p>
<!-- <!-- This custom function `plot_SS()` takes three arguments, `tre` (a tree variable of class `phy`), `SS` (output from `search.shift()`), and `tax` (a ~~tibble/data.frame~~ a list, containing ~~the column `species` and `higher_taxon`)~~ clade/lineage names and their species. ~~We have the higher taxon names stored in our PCA tibbles (`hindwing.pca2`, etc.)~~. Please load the taxon name list by downloading [this R data file](Lep_classification.RDS). -->
<p>–&gt;</p>
<!-- <!-- The function returns a plot under `$plot` and the `search.shift()` results under `$res`. -->
<p>–&gt;</p>
<!-- <!-- Let's try it out by first loading the taxon names with `readRDS()`. -->
<p>–&gt;</p>
<!-- <!-- ```{r newplot} -->
<p>–&gt; <!-- <!-- tax.names <- readRDS("Lep_classification.RDS") -->
–&gt;</p>
<!-- <!-- hindPC1.res <- plot_SS(lep.tree2,hindPC1.SS,tax = tax.names) -->
<p>–&gt;</p>
<!-- <!-- hindPC1.res$plot -->
<p>–&gt; <!-- <!-- hindPC1.res$res --> –&gt;</p>
<!-- <!-- ``` -->
<p>–&gt;</p>
<!-- <!-- Notice that the clades and their taxa are color coded and the exceptional shifts are indicated by triangles (blue and down for low shifts, red and up for high shifts). Now we have a method of indicating what clades/lineages underwent a shift and the scale of the shift. -->
<p>–&gt;</p>
<!-- <!-- ```{r comp,eval=FALSE,include=FALSE} -->
<p>–&gt;</p>
<!-- <!-- forePC1.RR <- RRphylo(tree=lep.tree2,y=fore.pc1) -->
<p>–&gt;
<!-- <!-- forePC1.SS<- search.shift(RR=forePC1.RR,status.type="clade") -->
–&gt;
<!-- <!-- forePC1.plot <- plotShift(RR=forePC1.RR,SS=forePC1.SS) -->
–&gt; <!-- <!-- forePC1.plot$plotClades() --> –&gt;</p>
<!-- <!-- forePC1.res <- plot_SS(lep.tree2,SS=forePC1.SS,tax = tax.names) -->
<p>–&gt;</p>
<!-- <!-- forePC1.res$plot -->
<p>–&gt; <!-- <!-- forePC1.res$res --> –&gt;</p>
<!-- <!-- forePC2.RR <- RRphylo(tree=lep.tree2,y=fore.pc2) -->
<p>–&gt;
<!-- <!-- forePC2.SS<- search.shift(RR=forePC2.RR,status.type="clade") -->
–&gt;
<!-- <!-- forePC2.plot <- plotShift(RR=forePC2.RR,SS=forePC2.SS) -->
–&gt; <!-- <!-- forePC2.plot$plotClades() --> –&gt;</p>
<!-- <!-- forePC2.res <- plot_SS(lep.tree2,SS=forePC2.SS,tax = tax.names) -->
<p>–&gt;</p>
<!-- <!-- forePC2.res$plot -->
<p>–&gt; <!-- <!-- forePC2.res$res --> –&gt;</p>
<!-- <!-- hindPC2.RR <- RRphylo(tree=lep.tree2,y=hind.pc2) -->
<p>–&gt;
<!-- <!-- hindPC2.SS<- search.shift(RR=hindPC2.RR,status.type="clade") -->
–&gt;
<!-- <!-- hindPC2.plot <- plotShift(RR=hindPC2.RR,SS=hindPC2.SS) -->
–&gt; <!-- <!-- hindPC2.plot$plotClades() --> –&gt;</p>
<!-- <!-- hindPC2.res <- plot_SS(lep.tree2,SS=hindPC2.SS,tax = tax.names) -->
<p>–&gt;</p>
<!-- <!-- hindPC2.res$plot -->
<p>–&gt; <!-- <!-- hindPC2.res$res --> –&gt;</p>
<!-- <!-- ``` -->
<p>–&gt;</p>
<!-- <!-- ```{r comps,eval=FALSE,include=FALSE} -->
<p>–&gt; <!-- <!-- ### had relative wing size shifted --> –&gt;</p>
<!-- <!-- forewing.gp <- forewings %>% -->
<p>–&gt; <!-- <!--   coo_interpolate(fore.min) %>% --> –&gt;
<!-- <!--    coo_align()  %>% --> –&gt;
<!-- <!--   coo_slide(id=1) %>%  --> –&gt;
<!-- <!--   fgProcrustes() %>%  --> –&gt; <!-- <!--   coo_flipy() -->
–&gt;</p>
<!-- <!-- hindwing.gp <-hindwings %>%  -->
<p>–&gt; <!-- <!--    coo_interpolate(hind.min) %>%  --> –&gt;
<!-- <!--    coo_align()  %>% --> –&gt;
<!-- <!--    coo_slide(id=1) %>%  --> –&gt;
<!-- <!--   fgProcrustes() %>%  --> –&gt; <!-- <!--   coo_flipy() -->
–&gt;</p>
<!-- <!-- hind.area <- hindwing.gp %>%  -->
<p>–&gt; <!-- <!--   coo_trans(10,10) %>%  --> –&gt;
<!-- <!--   coo_area() --> –&gt;</p>
<!-- <!-- fore.area <- forewing.gp %>%  -->
<p>–&gt; <!-- <!--   coo_trans(10,10) %>%  --> –&gt;
<!-- <!--   coo_area() --> –&gt;</p>
<!-- <!-- area.prop <- fore.area/hind.area -->
<p>–&gt;</p>
<!-- <!-- area.dat <- tibble(FH=area.prop,xy.file=basename(names(area.prop)))%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data) %>%  --> –&gt;
<!-- <!--   filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!--   group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(FH=mean(FH)) --> –&gt;</p>
<!-- <!-- area <- area.dat$FH -->
<p>–&gt; <!-- <!-- names(area) <- area.dat$species --> –&gt;</p>
<!-- <!-- area.RR <- RRphylo(tree=lep.tree2,y=area) -->
<p>–&gt;
<!-- <!-- area.SS<- search.shift(RR=area.RR,status.type="clade") -->
–&gt; <!-- <!-- area.plot <- plotShift(RR=area.RR,SS=area.SS) --> –&gt;
<!-- <!-- area.plot$plotClades() --> –&gt;</p>
<!-- <!-- area.res <- plot_SS(lep.tree2,SS=area.SS,tax = tax.names) -->
<p>–&gt;</p>
<!-- <!-- area.res$plot -->
<p>–&gt;</p>
<!-- <!-- #AR -->
<p>–&gt;</p>
<!-- <!-- hind.w <- hindwing.gp %>%  -->
<p>–&gt; <!-- <!--   coo_length() --> –&gt;</p>
<!-- <!-- hindwing.AR <- hind.w^2/hind.area -->
<p>–&gt;</p>
<!-- <!-- fore.w <- forewing.gp %>%  -->
<p>–&gt; <!-- <!--   coo_length() --> –&gt;</p>
<!-- <!-- forewing.AR <- fore.w^2/fore.area -->
<p>–&gt;</p>
<!-- <!-- fore.AR <- tibble(AR=forewing.AR,xy.file=basename(names(forewing.AR)),wing="fore")%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data) %>%  --> –&gt;
<!-- <!--    filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!-- group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(AR=mean(log(AR)),wing="fore") --> –&gt;</p>
<!-- <!-- hind.AR <- tibble(AR=hindwing.AR,xy.file=basename(names(hindwing.AR)),wing="hind")%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data)%>%  --> –&gt;
<!-- <!--    filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!-- group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(AR=mean(log(AR)),wing="hind") --> –&gt;</p>
<!-- <!-- ar.dat <- rbind(hind.AR,fore.AR) -->
<p>–&gt;</p>
<!-- <!-- ar.dat %>% pivot_wider(names_from = wing, -->
<p>–&gt; <!-- <!--     values_from = AR) %>%  --> –&gt;
<!-- <!--   filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!--   summarize(fore=pic(fore,lep.tree2),hind=pic(hind,lep.tree2)) %>%  -->
–&gt; <!-- <!--   ggplot(aes(fore,hind))+geom_point() --> –&gt;</p>
<!-- <!-- fore.ar <- fore.AR$AR -->
<p>–&gt; <!-- <!-- names(fore.ar) <- fore.AR$species --> –&gt;</p>
<!-- <!-- hind.ar <- hind.AR$AR -->
<p>–&gt; <!-- <!-- names(hind.ar) <- hind.AR$species --> –&gt;</p>
<!-- <!-- fore.ar.RR <- RRphylo(tree=lep.tree2,y=fore.ar) -->
<p>–&gt;
<!-- <!-- fore.ar.SS<- search.shift(RR=fore.ar.RR,status.type="clade") -->
–&gt;
<!-- <!-- fore.ar.plot <- plotShift(RR=fore.ar.RR,SS=fore.ar.SS) -->
–&gt; <!-- <!-- fore.ar.plot$plotClades() --> –&gt;</p>
<!-- <!-- fore.ar.res <- plot_SS(lep.tree2,SS=fore.ar.SS,tax = tax.names) -->
<p>–&gt; <!-- <!-- fore.ar.res$plot --> –&gt;
<!-- <!-- fore.ar.res$res --> –&gt;</p>
<!-- <!-- hind.ar.RR <- RRphylo(tree=lep.tree2,y=hind.ar) -->
<p>–&gt;
<!-- <!-- hind.ar.SS<- search.shift(RR=hind.ar.RR,status.type="clade") -->
–&gt;
<!-- <!-- hind.ar.plot <- plotShift(RR=hind.ar.RR,SS=hind.ar.SS) -->
–&gt; <!-- <!-- hind.ar.plot$plotClades() --> –&gt;</p>
<!-- <!-- hind.ar.res <- plot_SS(lep.tree2,SS=hind.ar.SS,tax = tax.names) -->
<p>–&gt; <!-- <!-- hind.ar.res$plot --> –&gt;
<!-- <!-- hind.ar.res$res --> –&gt;</p>
<!-- <!-- library(data.table) -->
<p>–&gt; <!-- <!-- Ix <- function(x,y,axes=F){ --> –&gt;
<!-- <!--   dt <- data.table(x=x,y=y) --> –&gt;
<!-- <!--   if(axes) dt[,x:=x-mean(range(x))]; dt[,y:=y-mean(range(y))] -->
–&gt;
<!-- <!--   dt[,products:=(y^2+y*lead(y)+lead(y)^2)*(x*lead(y)-lead(x)*y)] -->
–&gt; <!-- <!--   I <- dt[,.((1/12)*sum(products,na.rm = T))] --> –&gt;
<!-- <!--   names(I) <- "I.x" --> –&gt; <!-- <!--   return(I) --> –&gt;
<!-- <!-- } --> –&gt;</p>
<!-- <!-- fore.I <- sapply(1:length(forewing.gp),function(x) forewing.gp[x]) -->
<p>–&gt;
<!-- <!-- fore.I  <- lapply(fore.I, function(x) as.matrix(data.frame(x=c(x[,1]-min(x[,1])),y=c(x[,2])))) -->
–&gt;
<!-- <!-- fore.I <- sapply(fore.I, function(x) Ix(x[,2],x[,1])) %>% unlist -->
–&gt;</p>
<!-- <!-- forewing.gp[[1]] -->
<p>–&gt;</p>
<!-- <!-- fore.I <- tibble(I=fore.I,xy.file=basename(names(forewing.AR)),wing="fore")%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data) %>%  --> –&gt;
<!-- <!--    filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!-- group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(I=mean(I),wing="fore") --> –&gt;</p>
<!-- <!-- hind.I <- sapply(1:length(hindwing.gp),function(x) hindwing.gp[x])  -->
<p>–&gt;
<!-- <!-- hind.I  <- lapply(hind.I, function(x) as.matrix(data.frame(x=c(x[,1]-min(x[,1])),y=c(x[,2])))) -->
–&gt;
<!-- <!-- hind.I <- sapply(hind.I, function(x) Ix(x[,2],x[,1])) %>% unlist -->
–&gt;</p>
<!-- <!-- hind.I <- tibble(I=hind.I,xy.file=basename(names(hindwing.AR)),wing="hind")%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data) %>%  --> –&gt;
<!-- <!--    filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!-- group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(I=mean(I),wing="hind") --> –&gt;</p>
<!-- <!-- I.dat <- rbind(hind.I,fore.I) -->
<p>–&gt;</p>
<!-- <!-- I.dat %>% pivot_wider(names_from = wing, -->
<p>–&gt; <!-- <!--     values_from = I) %>%  --> –&gt;
<!-- <!--   filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!--   summarize(fore=pic(fore,lep.tree2),hind=pic(hind,lep.tree2)) %>%  -->
–&gt; <!-- <!--   ggplot(aes(fore,hind))+geom_point() --> –&gt;</p>
<!-- <!-- hind.I2 <- hind.I %>% pull(I) -->
<p>–&gt; <!-- <!-- names(hind.I2) <- hind.I %>% pull(species) --> –&gt;
<!-- <!-- hind.I.RR <- RRphylo(tree=lep.tree2,y=hind.I2) --> –&gt;
<!-- <!-- hind.I.SS<- search.shift(RR=hind.I.RR,status.type="clade") -->
–&gt; <!-- <!-- hind.I.plot <- plotShift(RR=hind.I.RR,SS=hind.I.SS) -->
–&gt; <!-- <!-- hind.ar.plot$plotClades() --> –&gt;</p>
<!-- <!-- hind.I.res <- plot_SS(lep.tree2,SS=hind.I.SS,tax = tax.names) -->
<p>–&gt; <!-- <!-- hind.I.res$plot --> –&gt;
<!-- <!-- hind.I.res$res --> –&gt;</p>
<!-- <!-- fore.I2 <- fore.I %>% pull(I) -->
<p>–&gt; <!-- <!-- names(fore.I2) <- fore.I %>% pull(species) --> –&gt;
<!-- <!-- fore.I.RR <- RRphylo(tree=lep.tree2,y=fore.I2) --> –&gt;
<!-- <!-- fore.I.SS<- search.shift(RR=fore.I.RR,status.type="clade") -->
–&gt; <!-- <!-- fore.I.plot <- plotShift(RR=fore.I.RR,SS=fore.I.SS) -->
–&gt; <!-- <!-- fore.ar.plot$plotClades() --> –&gt;</p>
<!-- <!-- fore.I.res <- plot_SS(lep.tree2,SS=fore.I.SS,tax = tax.names) -->
<p>–&gt; <!-- <!-- fore.I.res$plot --> –&gt;
<!-- <!-- fore.I.res$res --> –&gt;</p>
<!-- <!-- fore.ARI <- fore.I %>% left_join(fore.AR) -->
<p>–&gt;</p>
<!-- <!-- fore.ARI %>%  -->
<p>–&gt; <!-- <!--   ggplot(aes(AR,I))+geom_point() --> –&gt;</p>
<!-- <!-- fore.ARI %>% filter(AR>1.25) %>% pull(species) -->
<p>–&gt; <!-- <!-- hind.ARPC %>%  --> –&gt;
<!-- <!--   ggplot(aes(AR,I))+geom_point() --> –&gt;</p>
<!-- <!-- hind.ARPC %>%  -->
<p>–&gt; <!-- <!--   ggplot(aes(I,PC1))+geom_point() --> –&gt;</p>
<!-- <!-- ARI.dat <- ar.dat %>% left_join(I.dat) %>%  -->
<p>–&gt;
<!-- <!--   pivot_wider(names_from=c(wing),values_from=c(I,AR)) %>%  -->
–&gt;
<!-- <!--   left_join(out.data %>% select(species,identifier,higher_taxon) %>% unique) -->
–&gt;</p>
<!-- <!-- ARI.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(higher_taxon,I_fore/I_hind))+geom_boxplot()+ylim(c(-1,-0.5)) -->
–&gt;</p>
<!-- <!-- obj<-contMap(lep.tree2,log(hind.I2*1e10),plot=FALSE) -->
<p>–&gt; <!-- <!-- plot(obj,fsize=c(0.4,1),cex=0.1,lwd=2,res=200) -->
–&gt;</p>
<!-- <!-- #so cool!!!! VVVV -->
<p>–&gt;</p>
<!-- <!-- img.f <- list.files("/Users/Chris/Dropbox/Documents/bc (1)/3140.f22/other_stuff/lep_photos",recursive=T,full.names=T) -->
<p>–&gt; <!-- <!-- hi.AR <- ARI.dat %>% filter(AR_fore>1.5) %>% -->
–&gt; <!-- <!--   group_by(species) %>%  --> –&gt;
<!-- <!--   mutate(img.f=img.f[grep(identifier,img.f)]) --> –&gt;</p>
<!-- <!-- img1 <- hi.AR %>% ungroup %>% filter(AR_fore==max(AR_fore)) %>% pull(img.f) %>% readJPEG(.,native = TRUE) -->
<p>–&gt; <!-- <!-- p1 <- ARI.dat %>%  --> –&gt;
<!-- <!--   ggplot(aes(AR_fore,I_fore))+geom_point() --> –&gt;</p>
<!-- <!-- library(ggimage) -->
<p>–&gt; <!-- <!-- library(patchwork) --> –&gt; <!-- <!-- p1 +  -->
–&gt;
<!-- <!--   geom_image(data=hi.AR,aes(image=img.f),size=.1)+geom_point(data=hi.AR,col="red") -->
–&gt;</p>
<!-- <!-- hi.AR %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(x=AR_fore,y=1))+geom_image(data=hi.AR,aes(image=img.f))+theme_classic() -->
–&gt;</p>
<!-- <!-- ``` -->
<p>–&gt;</p>
<!-- <!-- ```{r comp0,eval=FALSE,include=FALSE} -->
<p>–&gt;</p>
<!-- <!-- forewing.nogp<- forewings %>% -->
<p>–&gt; <!-- <!--   coo_interpolate(fore.min) %>% --> –&gt;
<!-- <!--   coo_align()  %>% --> –&gt; <!-- <!--   coo_slide(id=1) -->
–&gt;</p>
<!-- <!-- hindwing.nogp<- hindwings %>% -->
<p>–&gt; <!-- <!--   coo_interpolate(hind.min) %>% --> –&gt;
<!-- <!--   coo_align()  %>% --> –&gt; <!-- <!--   coo_slide(id=1) -->
–&gt;</p>
<!-- <!-- l <- forewing.nogp %>%  -->
<p>–&gt; <!-- <!--   coo_length() --> –&gt;</p>
<!-- <!-- range(l) -->
<p>–&gt;</p>
<!-- <!-- hist(l,breaks=seq(0,2100,10)) -->
<p>–&gt;</p>
<!-- <!-- forewing.sc <- forewing.nogp %>%  -->
<p>–&gt;
<!-- <!--   mutate(scale=l<120,l=coo_length(.),xy.file=names(.)) %>% -->
–&gt; <!-- <!--   mutate(xy.file=basename(xy.file)) %>%  --> –&gt;
<!-- <!--   filter(scale==T) --> –&gt;</p>
<!-- <!-- forewing.sc <- forewing.sc$fac %>% left_join(out.data) %>% select(species,l,wing) %>%  -->
<p>–&gt; <!-- <!--   group_by(species,wing) %>%  --> –&gt;
<!-- <!--   summarize(l=mean(l)) --> –&gt;</p>
<!-- <!-- hindwing.sc <- hindwing.nogp %>%  -->
<p>–&gt;
<!-- <!--   mutate(scale=l<120,l=coo_length(.),xy.file=names(.)) %>% -->
–&gt; <!-- <!--   mutate(xy.file=basename(xy.file)) %>%  --> –&gt;
<!-- <!--   filter(scale==T) --> –&gt;</p>
<!-- <!-- hindwing.sc <- hindwing.sc$fac  %>% left_join(out.data) %>% select(species,l,wing) %>%  -->
<p>–&gt; <!-- <!--   group_by(species,wing) %>%  --> –&gt;
<!-- <!--   summarize(l=mean(l)) --> –&gt;</p>
<!-- <!-- #second moment in real terms -->
<p>–&gt;</p>
<!-- <!-- fw.outs <- sapply(1:length(forewing.nogp),function(x) forewing.nogp[x]) -->
<p>–&gt;
<!-- <!-- fw.outs  <- lapply(fw.outs, function(x) as.matrix(data.frame(x=c(x[,1]-x[1,1]),y=c(x[,2]-x[1,2]))) %>% coo_flipy()) -->
–&gt;</p>
<!-- <!-- fore.I <- sapply(fw.outs, function(x) Ix(x[,2],x[,1])) %>% unlist -->
<p>–&gt;</p>
<!-- <!-- fore.I <- tibble(I=fore.I,xy.file=basename(names(forewing.nogp)),wing="fore")%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data) %>%  --> –&gt;
<!-- <!--    filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!-- group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(I=mean(I),wing="fore") --> –&gt;</p>
<!-- <!-- hw.outs <- sapply(1:length(hindwing.nogp),function(x) hindwing.nogp[x]) -->
<p>–&gt;
<!-- <!-- hw.outs  <- lapply(hw.outs, function(x) as.matrix(data.frame(x=c(x[,1]-x[1,1]),y=c(x[,2]-x[1,2])))%>% coo_flipy()) -->
–&gt;</p>
<!-- <!-- hind.Isc <- sapply(hw.outs, function(x) Ix(x[,2],x[,1])) %>% unlist -->
<p>–&gt;</p>
<!-- <!-- hind.I <- tibble(I=hind.Isc,xy.file=basename(names(hindwing.nogp)),wing="hind")%>%  -->
<p>–&gt; <!-- <!--   left_join(out.data) %>%  --> –&gt;
<!-- <!--    filter(species%in% lep.tree2$tip.label) %>%  --> –&gt;
<!-- <!-- group_by(species) %>%  --> –&gt;
<!-- <!--   summarize(I=mean(I),wing="hind") --> –&gt;</p>
<!-- <!-- I.dat <- rbind(hind.I,fore.I) %>%  -->
<p>–&gt;
<!-- <!--   pivot_wider(names_from=wing, values_from=I,names_prefix="I_") -->
–&gt;</p>
<!-- <!-- I.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(I_fore,I_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt;</p>
<!-- <!-- sc.dat <- rbind(hindwing.sc,forewing.sc) %>%  -->
<p>–&gt;
<!-- <!--   pivot_wider(names_from=wing,values_from=l,names_prefix="L_") %>%  -->
–&gt;
<!-- <!--   left_join(ARI.dat %>% select(-I_fore,-I_hind)) %>%  -->
–&gt; <!-- <!--   left_join(I.dat) %>%  --> –&gt;
<!-- <!--   filter(I_hind<1e4,I_fore<1e4) --> –&gt;</p>
<!-- <!-- lep.tree3 <- keep.tip(lep.tree2,sc.dat$species) -->
<p>–&gt;</p>
<!-- <!-- sc.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(I_fore,I_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt;</p>
<!-- <!-- sc.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(log(L_hindwing),log(I_hind), col=AR_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt;</p>
<!-- <!-- sc.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(AR_fore,I_fore, col=AR_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt;</p>
<!-- <!-- sc.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(AR_hind,I_hind, col=AR_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt;</p>
<!-- <!-- sc.dat %>%  -->
<p>–&gt;
<!-- <!--   ggplot(aes(AR_hind,AR_fore, col=AR_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt; <!-- <!-- sc.dat %>%  --> –&gt;
<!-- <!--   ggplot(aes(I_hind,I_fore, col=AR_hind))+geom_point()+geom_smooth(method="lm") -->
–&gt;</p>
<!-- <!-- ###PIC (HERE) -->
<p>–&gt;</p>
<!-- <!-- pic2 <- function(x=.,sp=species,t=lep.tree3){ -->
<p>–&gt; <!-- <!--   names(x) <- sp --> –&gt; <!-- <!--   pic(x,t) -->
–&gt; <!-- <!-- } --> –&gt;</p>
<!-- <!-- length(lep.tree3$tip.label) -->
<p>–&gt;</p>
<!-- <!-- pic2(x=sc.dat$AR_hind,sp=sc.dat$species) -->
<p>–&gt; <!-- <!-- sc.dat %>% --> –&gt; <!-- <!--   ungroup() %>%  -->
–&gt;
<!-- <!--   dplyr::mutate_at(c("AR_hind","AR_fore","I_fore","I_hind"),pic2(x=.,sp=.$species)) -->
–&gt; <!-- <!-- ``` --> –&gt;</p>
<!-- <!-- ```{r comp4,eval=FALSE,include=FALSE} -->
<p>–&gt; <!-- <!-- library(mvMORPH) --> –&gt;</p>
<!-- <!-- #for.ar.sim <- make.simmap(lep.tree3, area, model="ER", nsim=1) -->
<p>–&gt;
<!-- <!-- #fore.ar.ou <- mvOU(for.ar.sim, area, model="OU1", diagnostic=FALSE, echo=FALSE) -->
–&gt; <!-- <!-- #plot(for.ar.sim) --> –&gt;</p>
<!-- <!-- library(geiger) -->
<p>–&gt;</p>
<!-- <!-- fore.I.dtt <- dtt(lep.tree2,fore.I2,nsim=1000, plot=TRUE,calculateMDIp=T) -->
<p>–&gt;
<!-- <!-- hind.I.dtt <- dtt(lep.tree2,hind.I2,nsim=1000, plot=TRUE,calculateMDIp=T) -->
–&gt;
<!-- <!-- fore.ar.dtt <- dtt(lep.tree2,fore.ar,nsim=1000, plot=TRUE,calculateMDIp=T) -->
–&gt;
<!-- <!-- hind.ar.dtt <- dtt(lep.tree2,hind.ar,nsim=1000, plot=TRUE,calculateMDIp=T) -->
–&gt;</p>
<!-- <!-- library(OUwie) -->
<p>–&gt;</p>
<!-- <!-- n.tip <- seq(1,Ntip(lep.tree2),by=4) -->
<p>–&gt; <!-- <!-- lep.tree3 <- keep.tip(lep.tree2,n.tip) --> –&gt;</p>
<!-- <!-- hind.ar2 <- data.frame(species=names(hind.ar),Reg=1,AR=hind.ar) %>%  -->
<p>–&gt; <!-- <!--   filter(species%in%lep.tree3$tip.label) --> –&gt;
<!-- <!-- hind.ar.BM1 <- OUwie(lep.tree3,hind.ar2,model=c("BM1")) -->
–&gt;
<!-- <!-- hind.ar.BMS <- OUwie(lep.tree3,hind.ar2,model=c("BMS")) -->
–&gt;
<!-- <!-- hind.ar.OU1 <- OUwie(lep.tree3,hind.ar2,model=c("OU1")) -->
–&gt;
<!-- <!-- hind.ar.OUM <- OUwie(lep.tree3,hind.ar2,model=c("OUM")) -->
–&gt;
<!-- <!-- hind.ar.OUMV <- OUwie(lep.tree3,hind.ar2,model=c("OUMV")) -->
–&gt;
<!-- <!-- hind.ar.OUMA <- OUwie(lep.tree3,hind.ar2,model=c("OUMA")) -->
–&gt;</p>
<!-- <!-- fits <- list(hind.ar.BM1, -->
<p>–&gt; <!-- <!-- hind.ar.BMS, --> –&gt; <!-- <!-- hind.ar.OU1, -->
–&gt; <!-- <!-- hind.ar.OUM, --> –&gt; <!-- <!-- hind.ar.OUMV, --> –&gt;
<!-- <!-- hind.ar.OUMA --> –&gt; <!-- <!-- ) --> –&gt;</p>
<!-- <!-- aics <- sapply(fits,function(x) x$"AICc") -->
<p>–&gt; <!-- <!-- fits[[which.min(aics)]] --> –&gt;
<!-- <!-- all(!duplicated(names(hind.ar))) --> –&gt;</p>
<!-- <!-- hindwing.pc3 <- hindwing.pca2 %>% filter(species%in%lep.tree3$tip.label)%>% select(PC1,PC2) %>% as.matrix -->
<p>–&gt;
<!-- <!-- rownames(hindwing.pc3) <- hindwing.pca2 %>% filter(species%in%lep.tree3$tip.label)%>%pull(species) -->
–&gt;</p>
<!-- <!-- sfs <- hindwing.pca2 %>% filter(species%in%lep.tree3$tip.label)%>% pull(higher_taxon) %>% as.factor -->
<p>–&gt;</p>
<!-- <!-- library(geomorph) -->
<p>–&gt;</p>
<!-- <!-- hind.Ppca <- gm.prcomp(hindwing.pc3,phy=lep.tree3,GLS = TRUE) -->
<p>–&gt;</p>
<!-- <!-- grps <- as.numeric(sfs) -->
<p>–&gt; <!-- <!-- names(grps) <- sfs --> –&gt;</p>
<!-- <!-- g.pal <- viridis_pal()(length(levels(sfs))) -->
<p>–&gt;
<!-- <!-- plot(hind.Ppca,phylo=T,phylo.par = list(tip.labels = TRUE, tip.txt.cex = .75, edge.width = 2,node.labels = FALSE),time.plot=T,bg=sfs,pch=22) -->
–&gt; <!-- <!-- shapeHulls(hind.p,groups =,group.cols=1:23) -->
–&gt;</p>
<!-- <!-- plot(stom.Ppca,axis1 = 1,axis2=2,phylo = T,tip.tex.cex=0.1,phylo.par = list(tip.labels = TRUE, tip.txt.cex = .75, edge.width = 2,node.labels = FALSE),bg=diet2,pch=22) -->
<p>–&gt;
<!-- <!-- legend("topleft", pch=22, pt.bg = unique(diet2), legend = rev(levels(diet2))) -->
–&gt;
<!-- <!-- shapeHulls(p12,groups = grps,group.cols = c("red","black"),group.lwd=c(2,2),group.lty = c(2, 2)) -->
–&gt; <!-- <!-- dev.off() --> –&gt;</p>
<!-- <!-- nrow(hindwing.pc3) -->
<p>–&gt; <!-- <!-- Ntip(lep.tree2) --> –&gt;
<!-- <!-- #https://onlinelibrary.wiley.com/doi/full/10.1111/evo.14238 -->
–&gt;</p>
<!-- <!-- td <- hindwing.pca2 %>% filter(species%in%lep.tree3$tip.label)%>% select(species,PC1,PC2,higher_taxon) %>% rename(tip=species) %>% as.matrix -->
<p>–&gt;
<!-- <!-- rownames(td) <-  hindwing.pca2 %>% filter(species%in%lep.tree3$tip.label)%>%pull(species) -->
–&gt;
<!-- <!-- phylomorphospace.gg(lep.tree3,hindwing.pc3,tip.aes=aes(x,y,col=higher_taxon),tip.dat=td) -->
–&gt;
<!-- <!--   phylomorphospace.gg <- function (tree, X, A = NULL, control = list(), tip.dat=NULL,tip.aes=NULL,cont.disc="cont",...)  -->
–&gt; <!-- <!-- { --> –&gt; <!-- <!--   if (class(tree) != "phylo")  -->
–&gt; <!-- <!--     stop("tree object must be of class 'phylo.'") -->
–&gt; <!-- <!--   if (nrow(X) != length(tree$tip))  --> –&gt;
<!-- <!--     stop("X must contain the same number of rows as species in tree.") -->
–&gt; <!-- <!--   if (is.null(rownames(X))) { --> –&gt;
<!-- <!--     warning("X is missing row names; assuming order of tip labels.") -->
–&gt; <!-- <!--     rownames(X) <- tree$tip.label --> –&gt;
<!-- <!--   } --> –&gt; <!-- <!--   if (ncol(X) != 2) { --> –&gt;
<!-- <!--     warning("X has more than 2 columns.  Using only the first 2 columns.") -->
–&gt; <!-- <!--     X <- X[, 1:2] --> –&gt; <!-- <!--   } --> –&gt;
<!-- <!--   if (is.null(A))  --> –&gt;
<!-- <!--     A <- apply(X, 2, fastAnc, tree = tree) --> –&gt;
<!-- <!--   con = list(col.edge = setNames(rep("black", nrow(tree$edge)),  -->
–&gt;
<!-- <!--                                  as.character(tree$edge[, 2])), col.node = setNames(rep("black",  -->
–&gt;
<!-- <!--                                                                                         max(tree$edge)), as.character(1:max(tree$edge)))) -->
–&gt; <!-- <!--   con[(namc <- names(control))] <- control --> –&gt;
<!-- <!--   if (hasArg(node.by.map))  --> –&gt;
<!-- <!--     node.by.map <- list(...)$node.by.map --> –&gt;
<!-- <!--   else node.by.map <- FALSE --> –&gt;
<!-- <!--   if (hasArg(node.size)) { --> –&gt;
<!-- <!--     node.size <- list(...)$node.size --> –&gt;
<!-- <!--     if (length(node.size) == 1)  --> –&gt;
<!-- <!--       node.size <- c(node.size, node.size) --> –&gt;
<!-- <!--   } --> –&gt; <!-- <!--   else node.size <- c(1, 1.3) -->
–&gt; <!-- <!--   if (hasArg(xlab))  --> –&gt;
<!-- <!--     xlab <- list(...)$xlab --> –&gt;
<!-- <!--   else xlab <- colnames(X)[1] --> –&gt;
<!-- <!--   if (hasArg(ylab))  --> –&gt;
<!-- <!--     ylab <- list(...)$ylab --> –&gt;
<!-- <!--   else ylab <- colnames(X)[2] --> –&gt;
<!-- <!--   if (hasArg(fsize))  --> –&gt;
<!-- <!--     fsize <- 0.75 * list(...)$fsize --> –&gt;
<!-- <!--   else fsize <- 0.75 --> –&gt;
<!-- <!--   if (hasArg(colors))  --> –&gt;
<!-- <!--     colors <- list(...)$colors --> –&gt;
<!-- <!--   else if (!is.null(tree$maps))  --> –&gt;
<!-- <!--     colors <- setNames(palette()[1:ncol(tree$mapped.edge)],  -->
–&gt;
<!-- <!--                        sort(colnames(tree$mapped.edge))) -->
–&gt; <!-- <!--   if (hasArg(lwd))  --> –&gt;
<!-- <!--     lwd <- list(...)$lwd --> –&gt;
<!-- <!--   else lwd <- if (is.null(tree$maps))  --> –&gt;
<!-- <!--     1 --> –&gt; <!-- <!--   else 2 --> –&gt;
<!-- <!--   if (hasArg(axes))  --> –&gt;
<!-- <!--     axes <- list(...)$axes --> –&gt;
<!-- <!--   else axes <- TRUE --> –&gt;
<!-- <!--   if (hasArg(add))  --> –&gt;
<!-- <!--     add <- list(...)$add --> –&gt;
<!-- <!--   else add <- FALSE --> –&gt;
<!-- <!--   aa <- setNames(c(X[tree$tip.label, 1], A[, 1]), c(1:length(tree$tip.label),  -->
–&gt;
<!-- <!--                                                     rownames(A))) -->
–&gt;
<!-- <!--   bb <- setNames(c(X[tree$tip.label, 2], A[, 2]), c(1:length(tree$tip.label),  -->
–&gt;
<!-- <!--                                                     rownames(A))) -->
–&gt;
<!-- <!--   XX <- matrix(aa[as.character(tree$edge)], nrow(tree$edge),  -->
–&gt; <!-- <!--                2) --> –&gt;
<!-- <!--   YY <- matrix(bb[as.character(tree$edge)], nrow(tree$edge),  -->
–&gt; <!-- <!--                2) --> –&gt; <!-- <!--   if (!add)  -->
–&gt;</p>
<!-- <!--     A.df <- as.data.frame(A) -->
<p>–&gt;</p>
<!-- <!--   edge.path<- data.frame(x.beg=XX[,1],x.end=XX[,2],y.beg=YY[,1],y.end=YY[,2]) -->
<p>–&gt;</p>
<!-- <!--   zz <- c(tree$edge[1, 1], tree$edge[tree$edge[, 2] > length(tree$tip.label),2]) -->
<p>–&gt;
<!-- <!--   node.df <- data.frame(x=c(XX[1, 1], XX[tree$edge[, 2] > length(tree$tip.label),2]), y=c(YY[1, 1], YY[tree$edge[, 2] > length(tree$tip.label),2])) -->
–&gt;</p>
<!-- <!--   tip.df <- data.frame(x=XX[tree$edge[, 2] <= length(tree$tip.label), 2], y=YY[tree$edge[,2] <= length(tree$tip.label), 2],tip=tree$tip.label) -->
<p>–&gt;</p>
<!-- <!--   #print(tip.df) -->
<p>–&gt;</p>
<!-- <!--   #expand plot array -->
<p>–&gt; <!-- <!--   px <- 1.2*(tip.df$x) --> –&gt;
<!-- <!--   py <- 1.2*(tip.df$y) --> –&gt;
<!-- <!--   x.range <- max(px)-min(px) --> –&gt;
<!-- <!--   y.range <- max(py)-min(py) --> –&gt;</p>
<!-- <!--   tip.df <- data.frame(x=XX[tree$edge[, 2] <= length(tree$tip.label), 2], y=YY[tree$edge[,2] <= length(tree$tip.label), 2],tip=tree$tip.label,angle=(tip.df$x)/range(tip.df$x)*90,vjust=(tip.df$x/x.range)*2,hjust=(tip.df$y/y.range)) -->
<p>–&gt;</p>
<!-- <!--   if(!is.null(tip.dat)) tip.df <- merge(tip.df,tip.dat,by="tip") -->
<p>–&gt; <!-- <!--   print(tip.df) --> –&gt;
<!-- <!--   if(is.null(tip.aes)) tip.aes <- aes(x,y) --> –&gt;</p>
<!-- <!--   print(tip.aes) -->
<p>–&gt;</p>
<!-- <!--   gg.p <- ggplot(data=edge.path)+geom_segment(aes(x=x.beg,y=y.beg,xend=x.end,yend=y.end),alpha=0.5)+geom_point(data=node.df,aes(x=x,y=y),alpha=0.5,size=5)+geom_point(data=tip.df,tip.aes,size=7,inherit.aes = F)+geom_text(data=tip.df,aes(x=x,y=y,label=tip,fontface=3,angle=angle,vjust=vjust),size=5)+scale_x_continuous(limits=range(px))+scale_y_continuous(limits=range(py))+xlab(label = "PC1")+ylab(label="PC2") -->
<p>–&gt;</p>
<!-- <!--   return(gg.p+theme_bw(30)+theme(panel.grid=element_blank(),axis.title.x = element_text(vjust=-0.5),axis.title.y = element_text(vjust=0.25)) -->
<p>–&gt; <!-- <!--   ) --> –&gt;</p>
<!-- <!--   } -->
<p>–&gt;</p>
<!-- <!--   Betts, C.R. and Wootton, R.J., 1988. Wing shape and flight behaviour in butterflies (Lepidoptera: Papilionoidea and Hesperioidea): a preliminary analysis. Journal of experimental biology, 138(1), pp.271-288. -->
<p>–&gt;
<!-- <!--   Le Roy, C., Debat, V. and Llaurens, V., 2019. Adaptive evolution of butterfly wing shape: from morphology to behaviour. Biological Reviews, 94(4), pp.1261-1281. -->
–&gt; <!-- <!-- ``` --> –&gt;</p>
<!-- ## Shape evolution correlation -->
<!-- To say something about whether hing- and forewing shape evolution is correlated we could undertake phylogenetic least squares analysis like we have in previous projects. But, we've done a ton already. So, let's make this simple and just perform [phylogenetic independent contrasts (PIC)](https://en.wikipedia.org/wiki/Phylogenetic_comparative_methods#:~:text=Phylogenetically%20independent%20contrasts,-The%20standardized%20contrasts&text=The%20logic%20of%20the%20method,statistically%20independent%20and%20identically%20distributed.) analysis. First proposed by @felsenstein1985phylogenies in his seminal paper, he proposed using phylogenetic information (under a Brownian-motion like model) to transform the original tip data into values that are statistically independent of one another. This method is captured in the `ape` function `pic()` For hindwing and forewing PC1, such analysis would look like this. -->
<!-- ```{r pic1,eval=F} -->
<!-- hindPC1.pic <- pic(hind.pc1,phy = lep.tree2) -->
<!-- forePC1.pic <- pic(fore.pc1,phy = lep.tree2) -->
<!-- ``` -->
<!-- ```{r pic, include=FALSE,eval=FALSE} -->
<!-- hindPC2.pic <- pic(hind.pc2,phy = lep.tree2) -->
<!-- forePC2.pic <- pic(fore.pc2,phy = lep.tree2) -->
<!-- PC2.pic <- tibble( -->
<!--   hind=hindPC2.pic, -->
<!--   fore=forePC2.pic -->
<!-- ) -->
<!-- PC2.pic %>%  -->
<!--   ggplot(aes(x=fore,y=hind))+geom_point()+geom_smooth(method="lm") -->
<!-- ``` -->
<!-- Here we just inputed our stored PC vectors we used in the rate analysis and our tree of course. Now we have transformed values we can regress against one another. Let's first plot them and see what we get. -->
<!-- ```{r picplot,eval=F} -->
<!-- PC1.pic <- tibble( -->
<!--   hind=hindPC1.pic, -->
<!--   fore=forePC1.pic -->
<!-- ) -->
<!-- PC1.pic %>%  -->
<!--   ggplot(aes(x=fore,y=hind))+geom_point()+geom_smooth(method="lm") -->
<!-- ``` -->
<!-- Wow! These PC1s Look pretty correlated! Let's see what the r-squared value is and if there is a significant relationship. For this, we need simply to create a linear model and retrieve these values with `summary()`. -->
<!-- ```{r picmod} -->
<!-- summary(lm(hind~fore,PC1.pic)) -->
<!-- ``` -->
<!-- # Project Report -->
<!-- Please submit your report to your team GitHub repository as an .Rmd document with HTML output that addresses the following: -->
<!--   * Are the rates of wing-shape evolution different between the hind- and forewing? By how much?  -->
<!--   <!-- * Have major lineages of the Lepidoptera undergone significant shifts in evolutionary rate?  -->
<p>–&gt; <!--   * Are hind- and forewing shapes correlated? -->
<!--   * What inferences can you make based on shape correlations and flight control? --></p>
<!-- Please be sure to answer these questions based on both PC1 and PC2 shape scores. -->
<!-- In answering your question, your .Rmd should include the following components: -->
<!--    * A YAML header that specifies HTML output, the authors, and a bibliograph named "BIOL3140.bib". **Submit this bibliography as well!** -->
<!--    * Sections including an introduction, methods, results, discussion, author contributions, and references. Make sure that each, aside from the references, includes one to two short paragraphs. Specifially: -->
<!--       + Introduction: Frame the questions, indicating why they are important, what background work has been done in this realm, and how you will answer them. **Please include at least one reference to support the summary of previous work.** Note: this can be done easily by refiguring the introduction to this project report. -->
<!--       + Methods: Explicitly state how you answered the questions, including a narrative of all the anlyses both qualitative and quantitative. -->
<!--       + Results: Include any appropriate figures or tables and a narrative of the main results that are important to answering the questions. -->
<!--       + Discussion: Succinctly declare how the results relate to the question and how they compare to previous work devoted to the topic. In addition, be sure to comment on the importance of your findings to the broader topic at hand. **Please include at least one reference to another relevant study.** Note: circling back to the introductions, both to this project description and yours, will be helpful here. -->
<!--       + Author contributions: Briefly outline what each team member contributed to the project. -->
<!-- Project reports should be uploaded by 11:59 PM on Sunday, October 29th. -->
<!-- # References -->
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-grogan2012origin" class="csl-entry">
Grogan, Eileen D, Richard Lund, and Emily Greenfest-Allen. 2012.
<span>“The Origin and Relationships of Early Chondrichthyans.”</span>
<em>Biology of Sharks and Their Relatives</em> 2: 3–29.
</div>
<div id="ref-lauder2015swimming" class="csl-entry">
Lauder, George V, and Valentina Di Santo. 2015. <span>“Swimming
Mechanics and Energetics of Elasmobranch Fishes.”</span> In <em>Fish
Physiology</em>, 34:219–53.
</div>
<div id="ref-stein2018global" class="csl-entry">
Stein, R William, Christopher G Mull, Tyler S Kuhn, Neil C Aschliman,
Lindsay NK Davidson, Jeffrey B Joy, Gordon J Smith, Nicholas K Dulvy,
and Arne O Mooers. 2018. <span>“Global Priorities for Conserving the
Evolutionary History of Sharks, Rays and Chimaeras.”</span> <em>Nature
Ecology &amp; Evolution</em> 2 (2): 288–98.
</div>
<div id="ref-sternes2020body" class="csl-entry">
Sternes, Phillip C, and Kenshu Shimada. 2020. <span>“Body Forms in
Sharks (Chondrichthyes: Elasmobranchii) and Their Functional,
Ecological, and Evolutionary Implications.”</span> <em>Zoology</em> 140:
125799.
</div>
<div id="ref-thomson1976heterocercal" class="csl-entry">
Thomson, Keith Stewart. 1976. <span>“On the Heterocercal Tail in
Sharks.”</span> <em>Paleobiology</em> 2 (1): 19–38.
</div>
<div id="ref-thomson1977body" class="csl-entry">
Thomson, Keith Stewart, and Dan E Simanek. 1977. <span>“Body Form and
Locomotion in Sharks.”</span> <em>American Zoologist</em> 17 (2):
343–54.
</div>
<div id="ref-wilga2004biomechanics" class="csl-entry">
Wilga, Cheryl AD, and George V Lauder. 2004. <span>“Biomechanics of
Locomotion in Sharks, Rays, and Chimeras.”</span> <em>Biology of Sharks
and Their Relatives</em> 5: 139–64.
</div>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
