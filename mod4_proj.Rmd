---
title: "Module 4 Project"
bibliography: class.bib
---
<style>
div.green { background-color:#c7d1c0; border-radius: 5px; padding: 20px;}
</style>

<!-- Add icon library -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">

# Introduction

Now that we've learned (at breakneck speed!) some ins and outs of data analysis, visualization, and modeling, we'll turn to how a scientist can easily organize, share, and communciate results and ideas. Communication of the results of any research in scienec is, at its final stage, usually done through publishing scientific papers. However, before this final product, scientists must catalog the maturation of their work and often seek to repetedly share it with collaborators. Cataloging the progress and sharing preliminary results can take many forms: exchanging scripts that analyze data, giving presentations to colleagues, and passing manuscripts back and forth between team members, just to name a few activities. 

From a mechanistic standpoint, the workflow for sharing progress is often decentralized. Want to share scripts? Send the over email or store them in cloud (or GitHub!). Want to give a presentation? Import figures from your scripts into a slide deck. Want to create and share a manuscript? Write up in a word-processing software and disstrubute over email or the cloud. Fortnately, there exists a unifying alternative: markdowns, an easy-to-read and easy-to-write plain text format that's then converted any one of a variety of formats (slides, PDF, HTML, etc.). For we scientists working in R, we can use R Markdown, giving us the added benefit of adding code and the results of our code to text and commentary about our work. It's one stop shopping.

In this project, we'll learn the basics of R Markdown. Specifically, we'll learn how author documents that include code, the graphics that are produced from it, and stylistically pleasing text that place the results of our analysis in context.

<center>

[![Alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)

</center>

Our tasks will be to:

  1. Familiarize ourselves with the R Markdown framework.
  2. Author simple R Markdown.
  3. Run code within an R Markdown document.
  4. Add graphics (i.e., figures), images, tables and references to and R Markdown document. 
  5. Render (i.e., knit) this R Markdown into HTML and PDF documents.

# Set up

First of all, let's precisely define what we mean by a markdown, the syntaxt for R Markdown. Markdown is a very simple ``markup" language which creates documents with headers, images, references, pieces of code and so much more from plain text files. Becuase it's text based, the document can be rendered into many other file formats like HTML or PDF that will contain the organized content.

To get R Markdown up and running, you don't need to do much at all if you're using R Studio. You just need to open a new markdown document. The machinery for formatting the source text file is loaded with R Studio. All you have to do is open a new markdown document in R Studio: ``File > New File > R Markdown". Notice this opens a tab with a markdown template named "untitled.Rmd". The ".Rmd" extensions informs R Studio that this is a source file for markdown and thus it will treat it as such. 


<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">

In R4DS, you may have noticed a discussion about the difference between R Markdown and R Notebooks. Notebooks are merely more compact version of R Markdowns. R Notebooks permit direct interaction with R while producing a reproducible document. However, any R Markdown document can be used as a notebook, so we'll bypass R Notebooks for now, and focus on R Markdowns.

</div>
</div>
</div>
<br>

Keep this document open and ready to edit. But, before was start, let's estabish the context for authoring an R Markdown. Say, thinking back to the [Module 3 Project](mod3_proj.html), we wanted to report on some of our results, how we came to them, and what they mean. In that project, we found that ecomorph was an important predictor of the hindlimb-SVL relationship in anoles. Specifically, we used phylogenetic least quares ananlyis to assess this relationship under Brownian motion and OU models of trait evolution.

To assemble such a report, we should include sections that reflect the the progression of the anaylsis, each containing text, figures, captions, and references. Our sections should include an introduction, methods, results, conclusions, and a bibliography. Our tasks for this project will be taken on in this context: producing a succinct and reproducible report on the analysis of anole hindlimb evolution. Let's get started.

# The YAML Header

You'll see at the top of your new ".Rmd" file a header contained between two lines (`---`). This is the YAML header that specifies the the attributes of the markdown. By default it includes a title, author, date and type of file for your output. These are but a few of the formatting options and settings that could apply to the whole document. For now, let's just include these, altering them to reflect your specific needs. For instance:

```
---
title: "Anole Ecomorph Hindlimb Evolution"
author: John Doe, Jane Doe, and Salmon Roe
date: 22/Sep/2020
output: html_document
---

```

Below the YAML header is the space where you'll include text, code, etc. 

# Headers

When you start putting together the content of an .Rmd, you should consider adding sections almost immediately. This can serve as an outline for the document. Headers provide a way of heirarchichally organizing the document into sections that refelct an outline. These are indentified in the markdown by using one or several `#`. The more you use, the smaller the text and, presumably the less inclusive the header. That is, `#` is the biggest header and `##` is typically nested within a `#` header, and `###` is nested within a `##` header. For instance, this 

```
# Header 1

Text under Header 1

## Header 2

Text under Header 2

### Header 3

Text under Header 3

```
will produce this:

# Header 1

Text under Header 1

## Header 2

Text under Header 2

### Header 3

Text under Header 3


In your future project reports for Phase II and III of the class, you'll always want to include sections for an introduction, methods, results, conclusions, and bibliography. We'll organize the .Rmd accordingly, so please add those sections to your .Rmd. with a high-level header `#`.  We'll add nested subsections and text later.  



```{r "load the data",include=FALSE,echo=FALSE}
library(tidyverse)
library(ape)
library(nlme)
library(MuMIn)
library(geiger)
anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")

anole2 <- anole%>%
left_join(anole.eco)%>%
  filter(!Ecomorph%in%c("U","CH"))%>%
  na.omit()

anole.log <- anole2%>%
  mutate_at(c("SVL", "HTotal","PH","ArbPD"),log)


### phylogenetic GLS models

#PGLS under BM, no ecomorph
pgls.BM1 <- gls(HTotal ~SVL, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under BM, w ecomorph
pgls.BM2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")


#PGLS under OU, no ecomorph
pgls.OU1 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, w, ecomorph
pgls.OU2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#AIC operations
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylow.aicw <- aicw(anole.phylo.aic$AICc)

#add phylo-corrected residuals
anole.log <- anole.log%>%
  mutate(phylo.res=residuals(pgls.BM2))

#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=Ecomorph2,y=phylo.res)) +geom_boxplot() +stat_summary(fun=mean, geom="point", size=3)

print(p.eco.phylo)

```

# Adding Code with Chunks

Code you include in your .Rmd should be written in sections enclosed by three backwards apostrophes (```). These sections are known as code chunks and look like this:


<pre><code>```{r}
x<-1:100
mean(50)
```</code></pre>


You can insert code chunks with by selecting the "insert" icon at the top of the the tab or my keying in "command+option+i". 

<center>

![](insertchunk.png)

</center>

To run the chunk, your can  click on "run" tap and selection "Run Current Chunk" or insert your cursor in the chunk and key in "command+shift+return". 

<center>

![](runchunk.png)

</center>

The content inside the curly brackets (`{}`) controls the behavior of code chunk. In this case, we're telling R markdown that the code inside the chunk is to be interpreted with R. This is a handy place to control the output of the code chunk. Let's jump right into how you would include code in chunks from our relavent anole project. 

At first, you'll want to include a chunk that loads the libraries you intend to use in the .Rmd. This can be added to the very top of the document. Something that looks like this:

<pre><code>```{r,include=FALSE}
library(tidyverse)
library(ape)
library(nlme)
library(MuMIn)
library(geiger)
```</code></pre>

Notice here that we included a behavior to the chunk, specifically  `include=FALSE`. This prevents the code, and the results from appearing in the finished file. 

With a few exceptions, the logical place to include the code that produces analyses or figures is in the results sections. This is where the first output of the code will likely be relavent. So, under the results section, insert the following code chunks that establish the data we need and performs the initial analysis for PGLS.


<pre><code>```{r, "load the data"}
anole <- read_csv("anole.dat.csv")
anole.eco <- read_csv("anole.eco.csv")
anole.tree <- read.tree("anole.tre")
```</code></pre>

<pre><code>```{r, "join, filter, mutate to log"}
anole2 <- anole%>%
left_join(anole.eco)%>%
  filter(!Ecomorph%in%c("U","CH"))%>%
  na.omit()

anole.log <- anole2%>%
  mutate_at(c("SVL", "HTotal","PH","ArbPD"),log)
```</code></pre>

<pre><code>```{r, "PGLS models"}
### phylogenetic GLS models

#PGLS under BM, no ecomorph
pgls.BM1 <- gls(HTotal ~SVL, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under BM, w ecomorph
pgls.BM2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corBrownian(1,phy = anole.tree,form=~Species),data = anole.log, method = "ML")


#PGLS under OU, no ecomorph
pgls.OU1 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")

#PGLS under OU, w, ecomorph
pgls.OU2 <- gls(HTotal ~SVL * Ecomorph2, correlation = corMartins(0,phy = anole.tree,form=~Species),data = anole.log, method = "ML")
```</code></pre>

<pre><code>```{r, "AIC"}
#AIC operations
anole.phylo.aic <- AICc(pgls.BM1,pgls.BM2,pgls.OU1,pgls.OU2)
anole.phylow.aicw <- aicw(anole.phylo.aic$AICc)
```</code></pre>

<pre><code>```{r, "add residuals"}
#add phylo-corrected residuals
anole.log <- anole.log%>%
  mutate(phylo.res=residuals(pgls.BM2))
```</code></pre>

  
<pre><code>``{r,"plot residuals", fig.cap="Boxplot of phylogenetically corrected hindlimb residuals versus anole ecomorph"}
#plot residuals
p.eco.phylo <- anole.log%>%
ggplot(aes(x=Ecomorph2,y=phylo.res)) +geom_boxplot() +stat_summary(fun=mean, geom="point", size=3)

print(p.eco.phylo)

```</code></pre>

Notice that for each chunk, we icluded some text in quotes. This identifies the chunk with a name or label, as R Markdown calls it. Each name must be unique. These names are useful especially when we render the document and any errors or warnings emerge. More on that later. 

Also notice that this last chunked named "plot residuals" has another parameter, `fig.cap`. This specifies a caption to produce under a figure produced from the chunk. In communicating result through visualizations, figures or otherwise, it's **essential that you include a description** caption. The caption should include what's going in the figure (e.g., type of plot, the axes, where the data come from). 

# Set the Working Directory No More

You may have noticed that we haven't yet set a working directory. 

# Modifying Text



The basic syntax of a markdown language, so oddly named, is formulated around mark up. This is similar to other mark up languages like HTML or XML in that it uses tags to define elements within a document. There are many often used tags that you should be familiar with and most can be found in this [R Markdown cheatsheet](https://rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf). Let's consider the text in first paragraph of the introduction to the [Module 3 Project](mod3_proj.html#Introduction) description in block quotes below.


>The central theme of this project will be to assess the morphological and allometric differences between ecomorphs within the genus *Anolis*. First coined by the famous evolutionary biologist and herpetologist Ernest Williams, the term ecomorph describes a group of species, perhaps not sharing a most recent common  ancestor, with a similar ecological niche and behavior within the context of this niche. His model for this concept was the genus *Anolis*, although the ecomorph construct has been widely applied to many other species (think reef fish and Darwin's Finches). 

<center>

>![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)

</center>

>Our tasks will be to:

 > 1. Visualize how hind limb length varies with size (i.e., allometry!).
>  2. Visualize and asses how hind limb length vs. size relationship covary with ecological niche.
>  3. Learn more complex operations in `ggplot` than we've undertaken so far. 
 >  4. Evaluate this hindlimb-size relationship using standard frequentist models within and without a phylogenetic context.
 >  5. Using an information theory approach, assess the fit of phylogenetically corrected models of hind-limb variation under different modes of character evolution.

## Basic Formatting

Notice that there are several pieces of text that have unique formats.  For instance the genus *Anolis* is italicized. This is accompblished by wrapping the text with `*` or `*Anolis*`. You could, just as easily, bold text with `**`, `**Anolis**` to produce **Anolis**. 

As you've probably noticed in reading markdowns so far, where any code and names of code are written inline  (i.e., not in a chunk), the convention is to outline it with a distinctive backgroud (ussualy gray). To do this, code-bearing text is wrapped in <code>&grave;&grave;</code>. So <code>&grave;ggplot&grave;</code> becomes `ggplot`.

## Links
While no links are included in the example above, they abound in this and many other .Rmd documents. Inserting them couldn't be easier. One just has to wrap the text in brackets followed by the link path in parenthes. For example,  `[class site](https://bcorgbio.github.io/class/)` gives us [class site](https://bcorgbio.github.io/class/), text linking us to our class site.

## Images
We also have an image inserted above. Inserting images can be useful for all sorts of reasons, especially when you'd like to include a graphic that is not produced by R and resides elsewhere, like say online. The image above is inserted with:

```
![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
```

Notice this is much like inserting a link, but we have to tell R markdown to stop interpreting text by including `!` before a set of brackets, then we include the file path (in this case, a URL). This is the simplest way to insert an image. But, say you want to include an image that is a live link as well. All you have to to is include the link tags around the image tags, like this: 

```
[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
```
<br> 

And this is what you'll get:

[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
<br>

This image isn't centered on the page. The easy way to modify the position of an image (or any element, really) is to use standard HTML tags. So wrapping `<center>` and `</center>` around our image code like so . . . 

```
<center>
[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
</center>
```

. . . gives us: 

<center>
[![An anolis lizard](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)](https://upload.wikimedia.org/wikipedia/commons/thumb/4/4b/Green_anole.jpg/320px-Green_anole.jpg)
</center>

<br>

Keep in mind that R markdown prefers .jpg or .png images.

<div class = "green">
<div class="row">
  <div class="col-sm-2"><a class="far fa-sticky-note fa-5x" style="color:#939681"></a> <!-- regular style --></div>
  <div class="col-sm-9">
Although it may appear as a coding free-for-all, the ability to include HTML markup in addition to R mardown language injects enormous flexibility. One can use all the standard methods of HTML formatting and wizardry to expand R Mardowns capabilities and charm. These note boxes, for example are a container class written in HTML.
</div>
</div>
</div>
<br>

Of course, one can aslo add local images, i.e., those stored on your computer. For instance, say we wanted to include a small version of the radogrpah image from the [Module 3 project Description](mod3_proj#Introduction), a .png stored in the same directory as this .Rmd file, we simply write

```
<center>
![](svl_small.png)
</center>
```

<center>
![](svl_small.png)
</center>
<br>






# Tables

## Tables from code.


# Fancy Bits

Add menue at side. 
# Project Report

It's likely that your head is spinning: we've covered a ton of topics in the project. What's left to do is merely pick up the high points of what we've explored and apply these in a few relatively straightforward operations. 

Let's have your team explore some ecological data and how it effects hindlimb-SVL patterns. We'll not take the a priori ecomorph designations for granted, but rather assess if important ecological parameters of perch height (how high in the tree the anole resides) and the diameter of the perch predicts discrete patterns in the hindlimb-SVL relationship. We''l use the log-transformed values of these variables are contained in the `anole.log` tibble.

For this project report, write a script named "groupname_module3.R" and undertake the following operations.
  
  1. Combine the code above so that you can establish the `anole.log` data tibble.
  2. Using the log-transformed data, construct two simple linear models that assess the effect of perch diameter and height by including these as covariates in your models. Be sure to use `+` notation rather than `*`, assuming there is no interaction (there isn't, trust me!).
  3. Explore how both perch diameter and height effect the hindlimb-SVL relationship by plotting the residuals of your simple linear models against these covariates. This will require mutating a data tibble to include residuals from both models. Please produce two separate plots.
  4. Under a BM model of trait evolution and using the tree provided, construct phylogenetic least squares models of the hindlimb-SVL relationships that include the unique combinations of these two covariates, i.e,
  
    * A PGLS model with the hindlimb-SVL relationship + perch height
    * A PGLS model with the hindlimb-SVL relationship + perch diameter
    * A PGSL model with the hindlimb-SVL relationship + perch height + perch diameter
    
  5. Assess the fit of each of these three models using AICc and AICw and comment on (with comments in the script) whether one or both of the covariates is a significant predictor of hinglimb length in a phylogenetic context. 
  6. Produce a plot of your own design that concisely visualizes the effect of your covariate(s) on the hindlimb residuals of the best fitting PGLS model. 
  7. Submit your script to [this link](https://forms.gle/5iD9u1ZmL7M3oNRN8).


Submissions are due by 11:59 PM on Sunday, September 27th.

# References